
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Lyu Dada</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Lyu Dada">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Lyu Dada">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lyu Dada">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Lyu Dada" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Lyu Dada</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">to love and get love</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="https://github.com/fromIRIS">MYGithub</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yoursite.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-移动端调试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/20/移动端调试/" class="article-date">
  <time datetime="2015-12-20T15:52:13.000Z" itemprop="datePublished">2015-12-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/20/移动端调试/">移动端调试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="移动端调试">移动端调试</h2><h3 id="前言">前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;移动端调试不同于桌面端调试，在桌面时代，chrome的调试器已经无比强大。但是在手机上调试web页面就没有这么原始的方式了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文就如何调试移动端web页面，借鉴了一些博文和目前市面上好用的工具，针对<code>移动端web页面</code>以及<code>APP内嵌webview页面</code>如何调试做了一个试用和整理。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先谈谈需求。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最理想的方式是什么？</p>
<ul>
<li>ios设备下<ul>
<li>H5页面</li>
<li>webview页面</li>
</ul>
</li>
<li>安卓设备<ul>
<li>H5页面</li>
<li>webview页面</li>
</ul>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最理想的状态就是在上述四种情况下，H5页面在各种浏览器下都可以进行调试，且调试的方式跟PC chrome类似，包含js断点调试。webview页面在微信以及公司的APP产品内可以进行类似PC chrome类似的调试方式，包含js断点调试。</p>
<hr>
<h3 id="IOS_设备">IOS 设备</h3><blockquote>
<p>1、 ios safari + mac safari + iphone真机  </p>
</blockquote>
<p><strong>调试safari浏览器的H5页面</strong></p>
<p>启用功能：</p>
<p>手机端：设置 → Safari → 高级 → Web 检查器 → 开。</p>
<p>mac端：Safari → 偏好设置 → 高级 → 在菜单栏中显示“开发”菜单。</p>
<p>然后就可以在电脑端调试iphone上的safari浏览器上的样式。在调试器及资源里<strong>可以对js打断点</strong>。操作方式跟chrome的调试器一样。不同的是我们是在手机上对页面进行操作，触发断点环境会更真实。</p>
<p>若在js中埋入一些console，在IOS真机上执行一些操作，mac端safari上调试器能打印，这能极大的方便复杂手势的一些操作。</p>
<p><strong>优点：包含js断点功能，调试方式跟桌面端chrome几乎一样</strong><br><strong>缺点：只能在手机上的safari浏览器上操作，不能覆盖其他手机环境，另外也不支持webview的调试。</strong></p>
<blockquote>
<p>2、万金油 weinre  + 真机</p>
</blockquote>
<p><strong>调试任意浏览器的H5页面以及webview页面</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用场景：有些时候样式在桌面chrome模拟是好的，但是在部分webview或者真机上就有问题。</p>
<ul>
<li>第一步：<code>npm install -g weinre</code></li>
<li>第二步：<code>weinre –boundHost xx ip</code><br>类似于<code>weinre –boundHost 172.16.28.162</code></li>
<li>第三步：此时weinre会返回一个可用的地址<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2015</span>-<span class="number">12</span>-<span class="number">14</span><span class="string">T03:</span><span class="number">58</span>:<span class="number">50.349</span>Z <span class="string">weinre:</span> starting server at <span class="string">http:</span><span class="comment">//10.1.2.77:8080</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>也可以指定端口号<br><code>weinre --httpPort 8081 --boundHost 172.16.28.162</code></p>
<ul>
<li>第四步：可以访问之前weinre分配过来的地址，进入后在页面最上部分可以看到<code>Access Points</code>下的<code>debug client user interface http://10.1.2.77:8080/client/#anonymous</code></li>
</ul>
<p><img src="http://cdn1.showjoy.com/images/9a/9a259c3bbf5d438399842c11d53054c9.png" alt="Alt text"><br>这是之后要点击的链接 ，我们先往当前网页下方看。可以看到<code>Target Script栏目</code><br><img src="http://cdn1.showjoy.com/images/ad/add8ce371e0e4f52898fe4f652427f50.png" alt="Alt text"><br>我们需要将<code>Example</code>的script标签复制粘贴到需要调试的项目中去。</p>
<ul>
<li><p>第五步：开启本地静态服务器（XMAPP等），进入到需要调试的项目的页面，例如<br><code>http://10.1.2.77:8000/index.html</code>我是利用nodejs开的一个小型服务器。<br><img src="http://cdn1.showjoy.com/images/d5/d53d31ba1bcd41749446ae158e923ed8.png" alt="Alt text"></p>
</li>
<li><p>第六步：此时可以回到第四步中的weine分配给你的地址，<br><img src="http://cdn1.showjoy.com/images/42/42eadf2d9af545629e14387a9c6c64bf.png" alt="Alt text"><br>点击第一条<code>debug client user interface:    http://10.1.2.77:8080/client/#anonymous</code>,进入预备调试页面。</p>
</li>
<li><p>第七步：在预备调试页面我们可以看到<br><img src="http://cdn1.showjoy.com/images/ca/ca2a26ecf08d4eca807ea1ec2374eee9.png" alt="Alt text"><br><code>Targets</code>下有一条可以选择的调试页面，对应着刚刚在本地静态服务器中打开的页面。但是这个页面是PC的，现在我们通过手机（浏览器、APP、微信等）进入这个项目ip地址<a href="http://10.1.2.77:8000/index.html" target="_blank" rel="external">http://10.1.2.77:8000/index.html</a><br>此时预备调试页面将会出现两条可调试地址<br><img src="http://cdn1.showjoy.com/images/42/426b2c9ab5504cc18c77b1da504e7270.png" alt="Alt text"><br>选择手机端进入后新增的地址。</p>
</li>
<li>第八步：点开链接后链接状态从蓝色变成绿色，然后再点击页面左上角的Element按钮。<br><img src="http://cdn1.showjoy.com/images/ae/ae11cb7dc7034bc4981503af603c6300.png" alt="Alt text"><br>现在就可以在pc端调试，手机端直接显示修改的变化啦。</li>
</ul>
<p><strong>优点：</strong>为何称weinre为万金油呢？因为只要在需要调试的项目的文件中引入weinre给出的<code>&lt;script&gt;标签</code>，再配合本地静态服务器的ip。<strong>可以在任何ios或安卓机型的包括浏览器和app的webview中去调试。</strong></p>
<p><strong>缺点：</strong> weinre不支持js的断点调试，这是一个缺憾，并且要在<strong>项目中引入额外的调试js标签</strong>。<br>但是对于js断点，可以在js逻辑中埋入console，然后在手机端真实操作，再在pc端的调试器中查看打印信息这种方式来代替。</p>
<blockquote>
<p>3、MIHTool </p>
</blockquote>
<p><strong>调试chrome safari浏览器的H5页面</strong><br>注意关闭翻墙代理噢。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于weinre 开发的一款APP， 只针对ios手机。大概使用方式是在APP内打开需要调试的页面，相应的在pc端浏览器会出现调试器，方可进行调试。使用MIHTool的最大优点之一在于不需要显式的引入调试所需的脚本。在此基础上，作者还增加了一些方便的功能。</p>
<ol>
<li>Performance API.</li>
<li>Polyfill管理器(模拟javascript与Native App互相调用,demo)</li>
<li>NPM Modules (在 web inspector console 里通过 require() 加载 npm 模块)</li>
</ol>
<p>具体可以看官网：<a href="http://www.mihtool.com/" target="_blank" rel="external">http://www.mihtool.com/</a></p>
<blockquote>
<p>4、ios模拟器 + mac safari</p>
</blockquote>
<p><strong>调试safari浏览器的H5页面（可进行js断点调试）</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在没有真机的情况下，可以采用模拟机的方式去运行ios系统下的safari浏览器，然后在safari浏览器内输入想要调试的页面。当然模拟ios系统必须在<code>Xcode</code>这个开发软件下进行。一旦在<code>Xcode</code>里开启了模拟机，再进入模拟机里的<code>safari</code>，之后按照上边介绍过的<code>真机 safari + mac safari</code>介绍的方式进行操作便可。<br><img src="http://cdn1.showjoy.com/images/ab/ab12718e529e4f03b1e17091e592b694.png" alt="Alt text"></p>
<blockquote>
<p>5、ios模拟器 + mac safari</p>
</blockquote>
<p><strong>调试公司APP内的webview页面（可进行js断点调试）</strong></p>
<p>参考 <a href="https://github.com/paulirish/iOS-WebView-App，因为不懂IOS开发，也不知道是如何进行的，但大概是在iOS项目内写一些方法抛出一个地址，然后在mac上的safari开发模式内识别出这个地址，然后就可以调试的。默认情况下，mac" target="_blank" rel="external">https://github.com/paulirish/iOS-WebView-App，因为不懂IOS开发，也不知道是如何进行的，但大概是在iOS项目内写一些方法抛出一个地址，然后在mac上的safari开发模式内识别出这个地址，然后就可以调试的。默认情况下，mac</a> safari只能识别usb连接的ios设备上的safari浏览器上的H5页面。（上面介绍过）</p>
<hr>
<h3 id="Android_设备">Android 设备</h3><blockquote>
<p>1、Android chrome 真机 + pc chrome</p>
</blockquote>
<p><strong>调试移动端浏览器的H5页面（可进行js断点调试）</strong></p>
<p>在安卓4.4版本以下的安卓机子，手机上安装了chrome的情况下，并且打开需要调试的页面，可以打开usb开发者模式，在pc端chrome地址栏输入<code>chrome://inspect</code>便可找到相应的手机的相应打开wap页面。调试方法跟pc chrome几乎一致。</p>
<p><strong>优点：</strong>可进行js断点调试。<br><strong>缺点：</strong>浏览器限制。</p>
<p><strong>调试公司APP内的webview页面（可进行js断点调试）</strong></p>
<p>在安卓4.4版本以上的安卓机子，手机通过usb连接mac电脑后，手机打开usb开发者模式后，在电脑chrome的<code>chrome://inspect</code>页面里会找到除了手机浏览器打开的页面，还会找到App内打开的webview的页面。<br><img src="http://cdn1.showjoy.com/images/ce/ce98e4652b7f47c99612a3081e4e785f.png" alt="Alt text"><br>点开<code>inspect</code>就是一个调试界面。</p>
<p>进行webview页面的调试 需要在应用的代码内设置才能生效（根据<a href="https://github.com/yujiangshui/CN-Chrome-DevTools/blob/remote-debugging/md/Use-Tools/remote-debugging.md#%E8%B0%83%E8%AF%95-webviews）" target="_blank" rel="external">https://github.com/yujiangshui/CN-Chrome-DevTools/blob/remote-debugging/md/Use-Tools/remote-debugging.md#%E8%B0%83%E8%AF%95-webviews）</a></p>
<blockquote>
<p>2、Android 模拟机 + pc chrome</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安卓模拟机配置成功的情况下调试的方式跟上面<code>1</code>方法是一样的，在安卓4.4版本以上才能进行webview的调试。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面就介绍下大名鼎鼎的安卓模拟器<code>genymotion</code>.个人使用是免费的。</p>
<ol>
<li>在其官网注册（必须）<a href="https://www.genymotion.com/" target="_blank" rel="external">https://www.genymotion.com/</a></li>
<li>在其官网下载最新的软件，下载完将genymotion和genymotion shell都放到应用程序内。</li>
<li>下完这个之后还需要下载virtualBox，<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">https://www.virtualbox.org/wiki/Downloads</a></li>
<li>之后就可以选择不同版本的模拟器了，网上的教程都是推荐下载安卓4.3版本，因为4.3版本有对应的补丁，装上后可以避免一些应用下载失败。但4.3版本不支持调试webview。我推荐下载 HTC one 4.4.4版本，本人试了很多版本，只有这个可以调试我司App内嵌的H5页面。<br><img src="http://cdn1.showjoy.com/images/b3/b38d848454e34984a0436989c4847139.png" alt="Alt text"></li>
</ol>
<p>推荐一个专门讲解<code>genymotion</code>的资源。<br><a href="http://www.ziliao1.com/Article/Show/DCDFC03FE4902A1AC353C74695DAC2E9.html" target="_blank" rel="external">http://www.ziliao1.com/Article/Show/DCDFC03FE4902A1AC353C74695DAC2E9.html</a><br>以及模拟机版本下载失败的解决办法<br><a href="http://www.cnblogs.com/wliangde/p/3678649.html" target="_blank" rel="external">http://www.cnblogs.com/wliangde/p/3678649.html</a></p>
<blockquote>
<p>3、万金油 weinre + pc chrome</p>
</blockquote>
<p><strong>调试任意浏览器的H5页面以及webview页面</strong></p>
<p>这个方法在之上iOS 部分已经讲解过了。weinre通吃安卓与ios，兼容性不要太高。</p>
<blockquote>
<p>4、微信调试</p>
</blockquote>
<p><strong>调试微信客户端的webview页面（支持js断点调试）</strong> </p>
<p>目前微信已经出了官方的调试工具，照着做就好了。<br><a href="http://blog.qqbrowser.cc/" target="_blank" rel="external">http://blog.qqbrowser.cc/</a></p>
<blockquote>
<p>5、UC浏览器 + 真机 + mac chrome</p>
</blockquote>
<p><strong>调试uc浏览器的H5页面（支持js断点）</strong></p>
<p>方法一是真机加上chrome浏览器，这个方法是真机加uc浏览器，<br><a href="http://www.uc.cn/business/developer/" target="_blank" rel="external">http://www.uc.cn/business/developer/</a></p>
<hr>
<h3 id="总结">总结</h3><p>上面罗列的多种方法，在本地开发的情况下基本都已经覆盖到了。但是如果线上页面出现bug了。该怎么办？最快的方法直接对线上页面进行调试。<br>先介绍一下mac抓包工具<code>charles</code></p>
<h4 id="charles">charles</h4><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=400497314&amp;idx=1&amp;sn=850fad741fdb635c2403bafb2f1e636f&amp;scene=1&amp;srcid=1119TqsnfhBHSKzA2BUja9mk&amp;key=ac89cba618d2d97693fea624e810ff69a7385f5209ab2a26ec029ca8f618e760e87de444299655bad41c5d1a7dbbc76e&amp;ascene=0&amp;uin=Mjg1NTY1OTY2MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.4+build(14E46" target="_blank" rel="external">charles使用详解 推荐</a>&amp;version=11020201&amp;pass_ticket=WPlsSiFuGxw6Tb6CFkzaSOMvY2gLt%2BQJpfSggleLZT0K5fuNOiMAgjLF110wuOSp)</p>
<p>1、截取http网络封包<br>2、支持修改网络请求参数<br>3、支持网络请求的截获并动态修改<br>4、支持重发网络请求<br>5、模拟网速网络</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;刚刚给出的链接中有charles的全方位解读，我这里就简单介绍下http网络封包。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在pc上charles可以很容易的创建一个代理，将设定的一部分网络请求全部转到charles代理上，并且可以将其中某个资源map到本地，从而实现使用本地代码调试线上代码的功能。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是我们现在是调试手机等移动端设备，但稍微做一些设置，就可以实现通过pc上的charles去代理移动端去请求资源。然后将需要的资源map到本地，进行修改和调试。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样设置过后的效果就是，在pc端修改代码，移动端线上的页面去请求本地修改后的代码并展示。</p>
<p>讲完了<code>charles</code>,问题回到如何快速调试线上页面。</p>
<p><strong>如果是H5页面</strong><br>遇上H5页面在PCchrome调试器上跟真实手机上的效果不一致时，可以使用万金油<code>weinre</code>，结合<code>charles</code>，就可以调试这种机型各种浏览器上的问题了。当然也可以使用上面提到的其他方法，都是适用的。</p>
<p><strong>如果是webview</strong><br>同样不能少的是<code>charles抓包</code>，如果是安卓可以配合<code>genymotion</code>模拟器进行模拟。使用方法上文讲述过，再推荐一篇专门的文章：<a href="http://div.io/topic/1449。" target="_blank" rel="external">http://div.io/topic/1449。</a><br>如果是ios，也可以采用这样的方式，即模拟器+charles+mac safari。使用方法在上文的ios章节讲述过。<br>当然也是可以使用万金油<code>weinre</code>。weinre+charles调试App内的H5页面也是很方便的。跟上面两种方法比较，缺少的就是js断点调试功能。</p>
<p><strong>参考文章</strong><br><a href="http://yujiangshui.com/multidevice-frontend-debug/" target="_blank" rel="external">移动端前端开发调试</a><br><a href="https://github.com/yujiangshui/CN-Chrome-DevTools/blob/remote-debugging/md/Use-Tools/remote-debugging.md#%E8%B0%83%E8%AF%95-webviews" target="_blank" rel="external">使用 Chrome 远程调试 Android 设备</a><br><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=400497314&amp;idx=1&amp;sn=850fad741fdb635c2403bafb2f1e636f&amp;scene=1&amp;srcid=1119TqsnfhBHSKzA2BUja9mk&amp;key=ac89cba618d2d97693fea624e810ff69a7385f5209ab2a26ec029ca8f618e760e87de444299655bad41c5d1a7dbbc76e&amp;ascene=0&amp;uin=Mjg1NTY1OTY2MA%3D%3D" target="_blank" rel="external">Charles 从入门到精通</a><br><a href="http://div.io/topic/1449" target="_blank" rel="external">打造最舒适的webview调试环境</a><br><a href="http://stackoverflow.com/questions/19700646/unable-to-create-genymotion-virtual-devicesconnection-timeout" target="_blank" rel="external">Unable to create Virtual Device</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/12/20/移动端调试/" data-id="ciifddu0y0006kgwl6bzklxs7" class="article-share-link" data-share="baidu">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端调试/">前端调试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-基于Gulp的前端静态页面开发工作流的思考" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/07/基于Gulp的前端静态页面开发工作流的思考/" class="article-date">
  <time datetime="2015-12-06T17:09:39.000Z" itemprop="datePublished">2015-12-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/07/基于Gulp的前端静态页面开发工作流的思考/">基于Gulp的前端静态页面开发工作流的思考</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="基于Gulp的前端静态页面开发工作流的思考">基于Gulp的前端静态页面开发工作流的思考</h2><p>写静态页面的时候最常见的脚手架就是下方这样的形式，本地新建一个项目文件，然后再在里面新建js、less文件夹，配合一个less处理，js压缩混淆的可视化工具，边写边处理，写完后再到tinyPng上压缩一下图片，需要将图片地址换成cdn的还需要将图片手动传到服务器上，最后大功告成！</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">-<span class="ruby">--js/</span><br><span class="line"></span>-<span class="ruby">--src/</span><br><span class="line"></span>-<span class="ruby">--less/</span><br><span class="line"></span>-<span class="ruby">--css/</span><br><span class="line"></span>-<span class="ruby">--images/</span><br><span class="line"></span>-<span class="ruby">--html</span></span><br></pre></td></tr></table></figure>
<p>但是可视化工具比如<code>codekit</code>的一个缺点就是可拓展性不高，局限于软件本身的功能。使用<code>gulp</code>以及强大的插件机制，可以带来无限的可能。<br>首先的问题就是项目文件目录该如何规划。如果只是上面提到的形式，生产代码跟发布代码混在同一个文件下，容易混淆。如果针对生产环境和发布环境分别对应一个文件夹就会清晰很多，如果两个文件夹的下属目录名称也相同，html文件引用资源的相对路径也就不需要改了。<br>先来看下项目脚手架的形式<br><img src="http://7xpcne.com1.z0.glb.clouddn.com/NYGulp1.png" alt="Alt text"></p>
<ul>
<li><code>src</code>为生产源代码，在编写的时候的代码都应该放入这个文件目录下，包括html文件。</li>
<li><code>dist</code>为上线的代码，里面存放的都是从src文件夹里压缩编译后的优化代码，包括html文件。</li>
<li><code>node_modules</code>存放的是相关于gulp的npm包。</li>
<li><code>config.json</code>有一些关于部署或者gulp需要的配置信息。</li>
<li><code>gulpfile.js</code>gulp的入口文件。</li>
<li><code>package.json</code>gulp所需插件的包管理。</li>
</ul>
<p>再来展开看一下<code>src</code>目录。<br><img src="http://7xpcne.com1.z0.glb.clouddn.com/NYGulp2.png" alt="Alt text"><br>生产源代码文件src下的目录结构</p>
<ul>
<li><code>css</code> 同文件下less编译后得到。</li>
<li><code>images</code> 图片</li>
<li><code>js</code> js文件</li>
<li><code>less</code>less文件</li>
<li><code>lib</code> 第三方库</li>
<li><code>index.html</code>  主页面</li>
</ul>
<p>再来看下<code>dist</code>文件目录<br><img src="http://7xpcne.com1.z0.glb.clouddn.com/NYGulp3.png" alt="Alt text"></p>
<ul>
<li><code>css</code>  src下的css文件压缩后得到</li>
<li><code>images</code> src下的images压缩得到</li>
<li><code>js</code>  src下的js文件压缩混淆得到</li>
<li><code>lib</code> 第三方库</li>
<li><code>index.html</code>  主页面</li>
</ul>
<hr>
<p>这篇文章假设大家已经基本了解了gulp如何安装使用，以及nodejs，npm包的使用。<br><a href="http://markpop.github.io/2014/09/17/Gulp%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" target="_blank" rel="external">http://markpop.github.io/2014/09/17/Gulp%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</a><br>不清楚gulp初始使用的同学可以看下这边文章，跟着做基本就懂了几个大概的插件用法。</p>
<hr>
<p>首先从此github上clone下来这个脚手架 <a href="https://github.com/fromIRIS/NYGulp" target="_blank" rel="external">https://github.com/fromIRIS/NYGulp</a><br>然后<code>npm install</code>安装所有需要的gulp插件。</p>
<hr>
<h3 id="代码编写阶段">代码编写阶段</h3><p>我对于gulp的使用流程是这样思考的，在编写代码的时候，并不需要时刻对js进行压缩，也不需要对图片进行压缩，唯一要做的是对less文件的编译（因为我平时工作都是less，所以本文css预处理器的基于less的）。当然也可以对js进行代码风格的检查。<br>所以在编写代码的时候我们只需开一个gulp默认的命令行并在内部进行css文件的监听就好。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp</span><br></pre></td></tr></table></figure></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">"serve"</span>, [<span class="string">"less"</span>, <span class="string">"js-watch"</span>, <span class="string">"html"</span>], <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    browserSync.init(&#123;</span><br><span class="line">        server : <span class="string">"./src"</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    gulp.watch(srcPath.LESS, [<span class="string">"less"</span>]);</span><br><span class="line">    gulp.watch(srcPath.JS, [<span class="string">"js-watch"</span>]);</span><br><span class="line">    gulp.watch(srcPath.HTML, [<span class="string">"html"</span>]);</span><br><span class="line">    gulp.watch(srcPath.HTML).on(<span class="string">"change"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        browserSync.reload;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(<span class="string">"less"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gulp.src(srcPath.LESS)</span><br><span class="line">        .pipe(less())</span><br><span class="line">        .pipe(gulp.dest(srcPath.CSS))</span><br><span class="line">        .pipe(browserSync.stream());</span><br><span class="line">&#125;)</span><br><span class="line">gulp.task(<span class="string">"js-watch"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gulp.src(srcPath.JS)</span><br><span class="line">    .pipe(browserSync.stream());</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">"html"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gulp.src(srcPath.HTML)</span><br><span class="line">    .pipe(browserSync.stream());</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">"default"</span>, [<span class="string">"serve"</span>])</span><br></pre></td></tr></table></figure>
<p>但是现在在编写代码的同时怎么还能持续的<code>command+R</code>呢，必须要用上时时刷新浏览器的功能啊，所以在代码编写的阶段，还要用到强大的<code>browser-sync</code>。这个插件最神奇的地方莫过于在一个终端操作，其他终端都能实时变化。比如在pc端填写表单，H5端也能实时的自动填写表单。<br><img src="http://7xpcne.com1.z0.glb.clouddn.com/NYGulp4120131606.gif" alt=""></p>
<h3 id="发布阶段_/1">发布阶段 /1</h3><p>代码写完了，在各个端都测试过觉得样式交互都ok了，感觉可以放到测试环境看看了，这个时候就可以对js文件进行压缩混淆，对css文件进行压缩，对图片进行压缩了。<br>这个时候在这个项目的根目录下执行这样的语句。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">gulp</span> build</span><br></pre></td></tr></table></figure></p>
<p>此时根目录下就会多了一个<code>dist</code>文件夹，就是上文提到的那个。这个<code>dist</code>文件夹里的文件都是用于线上/测试环境的，不能在这个文件夹里直接修改代码。</p>
<h3 id="发布阶段_/2">发布阶段 /2</h3><p>如果需要这个项目中使用<code>sprite雪碧图</code>，可以换一个命令，目前NYGulp只支持到PC的雪碧图自动生成。这个命令可以根据特定的图片文件夹生成一张sprite图片，并且自动将css文件中的<code>background-image</code>的地址替换掉，自动设置背景的<code>position</code>属性。<br>图片需要放在这个<code>src/images/slice</code> 目录下。<strong>是必须的啊</strong><br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">gulp</span> buildspritePc</span><br></pre></td></tr></table></figure></p>
<h3 id="更多思考">更多思考</h3><p>一个前端静态项目的js、less、图片的编译压缩通过gulp都自动进行着，最后还有一个问题，也是这个脚手架的最后一公里，就是如何自动化地根据项目中html文件中图片的相对路径将图片上传到公司所在的静态资源服务器，然后将相对路径自动替换成cdn地址。如果能做到这样，对于一个静态活动页面，就真正的做到了自动化，只用进行代码的书写，无需再处理图片的压缩上传。<br><a href="https://github.com/amfe/article/issues/8" target="_blank" rel="external">https://github.com/amfe/article/issues/8</a> , 事实上阿里的这个团队对前端自动化流的工具的研究已经很多了，从这篇文章里能找到解决思路，这也是我相继续深入的。<br>对于这样一个脚手架，在实际使用中已经较爽，可以利用 <a href="http://yeoman.io/" target="_blank" rel="external">Yeoman</a> 编写一个脚手架generator，这样在一个目录下执行一个命令就可以直接生成这个文件目录，免去了每次都要复制粘贴整个目录文档。</p>
<hr>
<p>参考资料：<br>browser-sync使用 <a href="http://segmentfault.com/a/1190000002919912" target="_blank" rel="external">http://segmentfault.com/a/1190000002919912</a><br>百度前端脚手架文档： <a href="https://github.com/ecomfe/spec/blob/master/directory.md#level1" target="_blank" rel="external">https://github.com/ecomfe/spec/blob/master/directory.md#level1</a><br>手淘前端自动化： <a href="https://github.com/amfe/article/issues/8" target="_blank" rel="external">https://github.com/amfe/article/issues/8</a><br>JGulp脚手架： <a href="http://segmentfault.com/a/1190000002658165" target="_blank" rel="external">http://segmentfault.com/a/1190000002658165</a><br>完！</p>
<p>原创文章，转载请注明出处！</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/12/07/基于Gulp的前端静态页面开发工作流的思考/" data-id="ciifddu12000ckgwloj7tdk79" class="article-share-link" data-share="baidu">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/杂/">杂</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-The-Principles-of-object-oriented-javascript阅读笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/29/The-Principles-of-object-oriented-javascript阅读笔记/" class="article-date">
  <time datetime="2015-11-29T15:52:59.000Z" itemprop="datePublished">2015-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/29/The-Principles-of-object-oriented-javascript阅读笔记/">The Principles of object-oriented javascript阅读笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="The_principles_of_object-oriented_javascript阅读笔记">The principles of object-oriented javascript阅读笔记</h2><hr>
<p>原书作者：Nicholas C.Zakas<br>笔记：南洋</p>
<p>面向对象的语言有如下几种特性：</p>
<ul>
<li>封装 数据可以和操作数据的功能组织在一起。</li>
<li>聚合 一个对象能够引用另一个对象</li>
<li>继承 一个新创建的对象和另一个对象拥有同样的特性。</li>
<li>多态 一个接口可悲多个对象实现。</li>
</ul>
<h3 id="第1章原始类型和引用类型">第1章原始类型和引用类型</h3><p>使用和理解对象是理解整个javascript的关键。<br>其他编程语言用栈存储原始类型，用堆储存引用类型。<br>javascript中的区别：</p>
<blockquote>
<p>它使用一个变量对象追踪变量的生存期，原始值被直接保存在变量对象中，而引用值则作为一个指针保存在变量对象上，该指针指向实际对象在内存中的存储位置。</p>
</blockquote>
<p><strong>1.2原始类型</strong><br>5种原始类型：</p>
<ul>
<li>boolean</li>
<li>number</li>
<li>string</li>
<li>null</li>
<li>undefined</li>
</ul>
<p>所有原始类型的值都有字面形式，&amp;&amp;&amp;字面形式是不被保存在变量中的值。eg.<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> name</span> = <span class="string">"nicholas"</span>;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> num</span> = <span class="number">13</span>;</span><br></pre></td></tr></table></figure></p>
<p>每个含有原始值的变量使用自己的存储空间，而这些变量保存在变量对象中。<br>下面这个表格很好说明了这个现象。</p>
<p><table><br>   <tr><br>       <td>variable object</td><br>   </tr><br>   <tr><br>      <td>color1</td><br>      <td>“red”</td><br>   </tr><br>   <tr><br>      <td>color2</td><br>      <td>“red”</td><br>   </tr><br></table><br> <strong>1.2.1 鉴别原始类型</strong><br> 鉴别原始类型的最好方式就是<code>typeof</code>，对于前三项原始类型，对应的typeof就是1、boolean2、number3、string。<br> 而对于空类型<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>) <span class="comment">// object</span></span><br></pre></td></tr></table></figure></p>
<p> 这个其实是一个错误， <strong>判断一个值是否为空类型的最佳方法是直接跟null比较 ===</strong><br> 要值得注意的是，因为<code>==</code>会强制转换类型，所以 <code>undefined == null</code>，所以这里空类型的判断还是使用<code>==</code></p>
<p><strong>1.2.2 原始方法</strong><br>字符串、数字、布尔也有方法，但是他们不属于对象（null undefined没有方法）。</p>
<p><strong>1.3 引用类型</strong><br>引用类型是指javascript中的对象。引用值是引用类型实例，也是对象的同义词。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="class"><span class="keyword">object</span> =</span> <span class="keyword">new</span> <span class="type">Object</span>();</span><br></pre></td></tr></table></figure></p>
<p>引用类型不在变量中直接保存对象，所以上面的代码变量<code>object</code>实际上并不包含对象的实例，而是包含一个指向内存中实际对象所在的位置的指针（引用）。</p>
<p><strong>1.3.2 对象引用解除</strong><br>在不使用某个对象时最好将引用解除，引用解除最好的方式是将保存引用的变量赋值<code>null</code></p>
<p><strong>1.3.3 添加删除属性</strong><br>在javascript中可以随时添加删除对象的属性，同一个对象的不同引用全部会随之改变。</p>
<p><strong>1.4 引用类型-内建类型</strong></p>
<ul>
<li>Array</li>
<li>Date</li>
<li>Error</li>
<li>Function</li>
<li>Object</li>
<li>RegExp<br>都可以通过new 来实例化每个内建引用类型。内建类型也有字面量形式。</li>
</ul>
<p><strong>1.6 鉴别引用类型</strong><br>1、function 鉴别函数还是可以用<code>typeof</code>返回值是  》》》 <code>function</code><br>2、对于数组和object、可以用<code>instanceof</code><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cosole.<span class="function"><span class="title">log</span><span class="params">([] insyanceof Array)</span></span>  <span class="comment">//true</span></span><br><span class="line">cosole.<span class="function"><span class="title">log</span><span class="params">(&#123;&#125; insyanceof Object)</span></span>  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注：instanceof能识别继承，即Array继承自Object， 所以[] instanceof Object   //true</strong></p>
<p><strong>1.8 原始封装类型</strong></p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean<br>当用到原始类型的方法时，才会生成对象，但是随后就会被销毁、<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> name</span> = <span class="string">"lvdada"</span>;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> firstChar</span> = name.charAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// javascript引擎</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> name</span> = 'lvdada';</span><br><span class="line"><span class="variable"><span class="keyword">var</span> temp</span> = new String(name);</span><br><span class="line"><span class="variable"><span class="keyword">var</span> firstChar</span> = temp.charAt(<span class="number">0</span>);</span><br><span class="line">temp = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="第2章_函数">第2章 函数</h3><p>函数其实就是对象，函数区别于其他对象的决定性特点在于函数存在一个被称为[[call]]的内部属性，这个属性不被代码访问，但定义了代码执行时的行为。<br>ECMA定义typeof操作符对任何具有[[call]]属性的对象返回”function”。由于函数是对象，所以其行为跟其他语言的行为不同，理解了函数的行为就是理解javascript的核心。</p>
<p><strong>2.1 声明还是表达式</strong><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> <span class="params">(num2, num1)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> <span class="params">(num1, num2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2<span class="string">'</span><br><span class="line">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>函数声明与函数表达式的区别在于表达式的尾部要加上分号。<br><strong>这里也特别强调，除了函数声明以外的任何javascript语句的尾部都要加上分号，以免解析器解析错误。</strong><br>另外一个重大的区别在于函数声明会发生变量提升的现象，跟var a = 13；的变量提升一样，但不同于原始数据类型的提升，函数声明的提升不会赋值为undefined。<br><strong>所以这样的影响就是可以在函数声明之前调用函数。</strong></p>
<p><strong>2.3 参数</strong><br>函数有一个属性<code>length</code>存的是函数期望的参数个数。<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> <span class="params">(num1, num2)</span> &#123;</span></span><br><span class="line">	<span class="keyword">return</span> num2 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="transposed_variable">a.</span><span class="built_in">length</span> <span class="comment">//2</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2.4 重载</strong><br>其他语言的函数存在重载模式，而javascript不存在重载，那是因为函数其实是对象，是Function的实例，当第二次定义重名的函数其实就是覆盖上一个同名函数。若要实现重载的功能，要依赖arguments.length或者检查参数是否存在。</p>
<p><strong>2.5 对象方法</strong><br>我们可以在任何时候给对象添加或删除属性。如果属性的值是函数，那么就称这个属性为方法。</p>
<p><strong>2.5.1 this 对象</strong><br>javascript所有的函数作用域内都有一个this对象代表<code>调用</code>该函数的对象。注意这里不是定义该函数的对象。我们知道函数的&amp;&amp;&amp;作用域是在函数定义时就决定了的，而this的查找的对象是调用时的对象。<br>这本书有个例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayNameForAll</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">	name: <span class="string">'nicho'</span>,</span><br><span class="line">	sayName: sayNameForAll</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">	name: <span class="string">'lvdada'</span>,</span><br><span class="line">	sayName: sayNameForAll</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Mich'</span>;</span><br><span class="line"></span><br><span class="line">person1.sayName() <span class="comment">// 'nicho'</span></span><br><span class="line">person2.sayName() <span class="comment">// 'lvdada'</span></span><br><span class="line"></span><br><span class="line">sayNameForAll() <span class="comment">// 'Mich'</span></span><br></pre></td></tr></table></figure></p>
<p>这个例子就说明了<code>this</code>在函数调用时才被设置为调用此函数的对象。</p>
<p><strong>2.5.2 改变this</strong><br>要改变<code>this</code>代表的对象有三种方法。</p>
<ul>
<li>call()</li>
<li>apply()</li>
<li>bind() ECMA5</li>
</ul>
<p>1、call<br>call是函数的一个方法，它以指定的this对象和具体的参数来<strong>执行函数</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayNameForAll</span> <span class="params">(label)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(label + <span class="string">':'</span> <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;	</span><br><span class="line">	name: <span class="string">'ni'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayNameForAll.call(person1, <span class="string">'hi'</span>);  <span class="comment">// 'hi:ni'</span></span><br></pre></td></tr></table></figure></p>
<p>直白的解释就是在执行sayNameForAll函数的时候，本来this会指向调用此函数的对象，但现在被显示的修改为<code>person1对象</code>，再传入一些这个函数需要的参数。</p>
<p>2、apply<br>跟call几乎完全一样，唯一的区别在后面的参数是以数组的形式传递进去的。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sayNameForAll<span class="list">(<span class="keyword">person1</span>, [<span class="quoted">'hi</span>'])</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>3、bind<br>这个方法是ECMA5定义的，低版本浏览器IE8不支持。bind跟call和apply的最大的区别在于，call，apply直接调用了那个函数。而bind不是。它是对函数声明时就限制this指向的对象，当一个函数调用bind方法时，并不直接执行这个函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayNameForAll</span> <span class="params">(label)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(label + <span class="string">':'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123; name: <span class="string">'nid'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> sayNameForPerson1 = sayNameForAll.bind(person1, <span class="string">'person1'</span>);</span><br><span class="line">sayNameForPerson1()  <span class="comment">// person1:nid</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要注意的是bind也能显示传入参数，上面的例子，bind的时候传入了'person1'字符串，在调用函数时就不需要传参数了。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="第3章_理解对象">第3章 理解对象</h3><blockquote>
<p>javascript中的对象是动态的，可以在代码执行的任意时刻发生改变。基于类的语言会根据类的定义锁定对象，javascript没有这种限制。</p>
</blockquote>
<p><strong>3.1 定义属性</strong></p>
<blockquote>
<p>当一个属性第一次被添加给对象时，javascript在对象上调用一个名为[[Put]]的内部方法，这个方法会在对象上创建一个新节点来保存初始的值，每添加一个属性，对象的内部都会调用一次这个方法，调用[[Put]]的结果是在对象上创建了一个自有属性，这个自有属性表明指定的对象实例拥有该悻，该属性被直接保存在实例中，对该属性的所有操作都必须通过该对象进行。</p>
</blockquote>
<p>而当一个已有的属性被替换为一个新值时，调用的是名为[[Set]]的方法。</p>
<p><strong>3.2 属性探测</strong><br>我们经常会如此判断一个对象的属性是否存在<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (person.age) &#123;</span><br><span class="line">	<span class="regexp">//</span> <span class="keyword">do</span> something <span class="reserved">with</span> age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果person.age = 0，这个属性是存在的，但是在判断时候会是<code>false</code>.判断属性是否存在的方式是使用<code>in</code>操作符或者是<code>hasOwnProperty方法</code>。<br>用法：<br> <code>&quot;name&quot; in person</code> 在person对象中是否存在name键名。<br> <code>person.hasOwnProperty(&#39;name&#39;)</code>在person对象中是否存在name键名。<br> 两者的区别在于，in会检索原型上的键名，也能找到不可枚举的键名，而hasOwnProperty只检索自有属性。</p>
<p><strong>3.4 属性枚举</strong><br><code>for in</code>会循环枚举一个对象所有的可枚举属性，也会跑到原型上去枚举那些可以被枚举的属性。<br><code>Object.keys()</code>返回一个对象的所有自有属性（返回数组类型）</p>
<hr>
<h3 id="第4章_构造函数和原型对象">第4章 构造函数和原型对象</h3><p><strong>4.1 构造函数</strong><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>每个实例在创建时都自动拥有一个constructor属性，这个属性包含了一个指向其构造函数的引用。</p>
</blockquote>
<p>eg<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cosnole.<span class="built_in">log</span>(person1.constructor === Person); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>但是这种判断最好不要用在判断某对象是否是一构造函数的实例，因为实例的<code>constructor</code>属性是来自原型的，可能会被覆盖。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1.<span class="function"><span class="title">hasOwnProperty</span><span class="params">(<span class="string">'constructor'</span>)</span></span>  <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p><strong>4.2 原型对象</strong></p>
<blockquote>
<p>几乎所有的函数都有一个名为 <code>prototype</code>的属性，该属性是一个原型对象，所有创建的对象实例共享该原型对象。且这些对象实例可以访问原型对象的属性。</p>
</blockquote>
<p>比如，<code>hasOwnProperty()</code>方法就存在Object.prototype原型对象中，而new出来的或者字面形式的对象都能调用该方法。</p>
<p>这里由个方法可以鉴别一个原型属性<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">hasPrototypeProperty</span> <span class="params">(<span class="keyword">object</span>, name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> name <span class="keyword">in</span> <span class="keyword">object</span> &amp;&amp; !<span class="keyword">object</span>.hasOwnProperty(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4.2.1 [[Prototype]]属性</strong></p>
<blockquote>
<p>一个对象实例通过内部属性[[Prototype]]跟踪其原型对象，该属性是一个指向该实例使用的原型对象的指针。</p>
</blockquote>
<p><code>[[prototype]]</code>属性读取方法<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">object</span> = <span class="comment">&#123;&#125;</span>;</span><br><span class="line"><span class="keyword">var</span> prototype = <span class="keyword">Object</span>.getPrototypeOf(<span class="keyword">object</span>);</span><br><span class="line">console.log(prototype === <span class="keyword">Object</span>.prototype); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>也有一种方法检测某个对象是否是另一个对象的原型对象。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="class"><span class="keyword">object</span> =</span> &#123;&#125;;</span><br><span class="line">console.log(<span class="type">Object</span>.prototype.isPrototypeOf(<span class="class"><span class="keyword">object</span>));</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>当访问一个对象的某个属性时，现在这个对象的自有属性中查找，若找不到，再去其原型对象中寻找。<br><strong>无法给一个对象的原型对象的属性赋值</strong>。<br>即给一个对象添加一个跟原型同名的属性时，只是增加一个自有属性，而不会去原型对象中去改写属性。</p>
<p><strong>4.2.2 在构造函数中使用原型对象</strong><br>直接用一个对象字面量替代原型对象是非常流行且方便的方式，但存在一个问题。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> <span class="params">(name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	sayName: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.name) &#125;,</span><br><span class="line">	toString: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;<span class="built_in">console</span>.log(<span class="string">''</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'ldd'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.constructor === Person); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.constructor === <span class="built_in">Object</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>为什么会发生这样的现象呢，上面解释过constructor是来自原型的constructor属性。当一个函数被创建时，它的prototype属性也被创建，即这个函数的原型对象，而原型对象具有constructor属性，并指向该函数。当用对象字面量改写了原型对象时，其constructor属性被置为Object，所以实例的constructor属性也指向了Object</p>
</blockquote>
<p>改进方法<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">	<span class="constructor"><span class="keyword">constructor</span>: Person, // 改进方法</span><br><span class="line">	sayName: function () </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.name) &#125;,</span><br><span class="line">	toString: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;<span class="built_in">console</span>.log(<span class="string">''</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>现在总结一下 <code>实例</code> <code>构造函数</code> <code>原型对象</code> 三者之间关系。<br>1、实例 通过内部的<code>[[prototype]]</code>属性指向原型对象<br>2、原型对象 通过constructor属性指向 构造函数<br>3、构造函数 通过prototype属性指向 原型对象<br>发现实例与构造函数之间没有明显的交流。</p>
</blockquote>
<p><strong>4.2.3 改变原型对象</strong></p>
<blockquote>
<p>[[Prototpe]]属性只是包含了一个指向原型对象的指针，任何对原型对象的改变都立即反映到所有引用它的对象实例上。<strong>这意味着给原型对象添加的新成员都可以立即被已经存在的对象实例使用</strong>、</p>
</blockquote>
<hr>
<h3 id="第5章_继承">第5章 继承</h3><p><strong>5.1 原型链和Object.prototype</strong><br><strong>原型链：</strong>对象实例继承了原型对象的属性，因为原型对象也是一个对象，它也有自己的原型对象并继承其属性。<br>所有对象都继承自Object.prototype</p>
<p><strong>5.2 对象继承</strong></p>
<blockquote>
<p>对象继承是最简单的继承类型，只需要指定一个对象是另一个对象的[[prototype]]。对象字面量形式会隐式的指定Object.prototype为另一个对象的[[prototype]]，当然也可以通过Object.create()方法显示的指定。</p>
</blockquote>
<p>实现的方式在<strong>5.3节</strong>会提到</p>
<p><strong>5.3 构造函数继承</strong></p>
<blockquote>
<p>上文中讲到，几乎所有的函数都有prototype属性（原型对象），且这个属性可以被修改和替换。当这个函数被创建时，该<code>prototype</code>属性被自动设置为一个新的继承自Object.prototype的对象，而且这个对象有一个自有属性constructor。<br>其实看看javascript引擎做的事情就好理解了。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当我们写下下面这行代码时</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">YourConstructor</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// javascript engine 会做这样的事情</span></span><br><span class="line">YourConstructor.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype, &#123;</span><br><span class="line">	<span class="constructor"><span class="keyword">constructor</span>: </span>&#123;</span><br><span class="line">		configurable: <span class="literal">true</span>,</span><br><span class="line">		enumerable: <span class="literal">true</span>,</span><br><span class="line">		value: YourConstructor,</span><br><span class="line">		writeable: <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p> 意思是当我们创建一个构造函数时，js引擎会自动的创建一个[[prototype]]为Object.prototype的，并且包含一个constructor属性的对象，赋值给构造函数的prototype属性。<br> 这样之后，就形成了2级原型链，<strong>实例继承自构造函数的原型对象，而这个原型对象又继承自Object.prototype</strong>。</p>
<blockquote>
<p>由于prototype属性是可以重写的，可以通过改写它来改变原型链。</p>
</blockquote>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Constructor1</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">Constructor1.prototype.add = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Constructor2</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">Constructor2.prototype = <span class="keyword">new</span> Constructor1();</span><br><span class="line">Constructor2.prototype.constructor = Constructor2;</span><br></pre></td></tr></table></figure>
<p>这里将Constructor2的原型对象置为了Constructor1的实例，跟上面js引擎的效果类似，原本Constructor2的原型对象应该是一个[[prototype]]为Object.prototype的对象，现在被赋值成了一个[[prototype]]为Constructor1.prototype的对象实例，根据原型链的概念，这样形成了继承。<br><strong>这里需要提起的是<code>new Constructor2 instanceof Constructor1</code> 这里就不能解释为new Constructor2 是 Constructor1的实例，因为<code>instanceof</code>是根据原型链判断的。</strong></p>
<p>这种继承方式是有问题的，因为<code>Constructor2.prototype = new Constructor1();</code> 如果Constructor1里有引用类型的值，比如数组，在Constructor2的原型对象里也会存在这个属性。而原型对象中的引用类型的属性是被所有实例共用的。</p>
<p>所以我们这里修改一下，不要带入被继承对象的内部属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Constructor2</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Contructor2.prototype = <span class="built_in">Object</span>.create(Contructor1.prototype, &#123;</span><br><span class="line">	<span class="constructor"><span class="keyword">constructor</span>: </span>&#123;</span><br><span class="line">		value: Constructor</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们在这里将Constructor2.prototype设置成一个只有constructor属性的并且[[prototype]]指向Constructor1.prototype的新对象，这样就不会带入污染物了。</p>
<p>但是通过原型链继承我们就拿不到父类的内部属性了，下面的代码可以解决。这种方式被称为伪类继承。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Constructor1</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">Constructor1.prototype.add = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Constructor2</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	Constructor1.call(<span class="keyword">this</span>);</span><br><span class="line">	<span class="comment">// 如此就可将Constructor1的属性复制到Constructor2了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Constructor1原型对象的属性复制来</span></span><br><span class="line">Contructor2.prototype = <span class="built_in">Object</span>.create(Contructor1.prototype, &#123;</span><br><span class="line">	<span class="constructor"><span class="keyword">constructor</span>: </span>&#123;</span><br><span class="line">		value: Constructor</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意接下来Constructor2原型对象不能携程对象字面量的形式</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/11/29/The-Principles-of-object-oriented-javascript阅读笔记/" data-id="ciifddu0a0000kgwl5nvobeuz" class="article-share-link" data-share="baidu">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/书籍阅读/">书籍阅读</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-编写可维护的javascript阅读笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/15/编写可维护的javascript阅读笔记/" class="article-date">
  <time datetime="2015-11-15T14:17:11.000Z" itemprop="datePublished">2015-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/15/编写可维护的javascript阅读笔记/">编写可维护的javascript阅读笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="编写可维护的javascript阅读总结">编写可维护的javascript阅读总结</h2><hr>
<h5 id="by_南洋_2015_11_14">by 南洋 2015 11 14</h5><hr>
<h3 id="第一部分_编程风格">第一部分 编程风格</h3><hr>
<p><strong>（一）、基本的格式化</strong><br><strong>1.1缩进层级</strong><br>第一种方式是使用制表符进行缩进，就是tab键好处是可以统一配置编辑器的配置改变制表符的长度，缺点是tab的表现在不同系统的变现可能不同，这样也会出现代码风格的不统一。<br>第二种方式是使用空格键，几个空格键代表一个缩进。<br><strong>我个人而言喜欢使用空格缩进并且两个空格代表一个缩进。</strong></p>
<p><strong>1.2语句结尾</strong><br>除了函数定义以外的代码结尾，都要加上分号，以免分析器错误的自动加上一些不必要的分号。</p>
<p><strong>1.3行的长度</strong><br>关于行的长度，sublime里有78的选项，个人一般会选择这个选项。如果长度太长，在浏览器里会超出视线，而且在github上也会出现横向滚动条，这都是阅读代码时不想看到的。</p>
<p><strong>1.4空行的使用</strong><br>这点自己做的不是很好，在书里出现的规则是：</p>
<ul>
<li>在流控制语句前加空行，比如if for</li>
<li>在方法内的局部变量与逻辑代码之间</li>
<li>每个方法之间</li>
<li>注释上下行</li>
</ul>
<p><strong>1.5命名</strong></p>
<blockquote>
<p>都采用驼峰式进行命名</p>
</blockquote>
<p>变量：前缀用名词，且名词能体现出这个变量的数据类型。<br>eg： countBox lengthBox msgUser</p>
<p>方法：前缀用动词<br>can has is set get</p>
<p>常量：<br>MAX_LENGTH<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">count</span> &gt; MAX_LENGTH) &#123;</span><br><span class="line">	<span class="comment">//TO DO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1.7基本量</strong><br>1.7.1字符串<br>字符串可以用双引号也可以用单引号，值得注意的是整个文件需要保持对这种字符串风格的统一。<br>个人比较喜欢用单引号。</p>
<p>1.7.2数字<br>不要省略0.4之前的0</p>
<p><strong>（二）、注释</strong><br><strong>2.1单行注释</strong><br>单独一行，用来注释下一行代码，注释的上一行要为空行。注释的缩进要和下一行的代码缩进相同。<br>或者注释在一行代码的尾部，要求注释的字数要少。注释与前的代码之间要有至少一个缩进。</p>
<p><strong>2.2多行注释</strong><br>多行注释出现在需要注释的一段代码之前，注释与代码之间没有空行，注释的上一行为空行。多行注释一般用来注释不好理解的代码段落。</p>
<p><strong>（三）、语句与表达式</strong><br><strong>3.1花括号的对其方式</strong><br>花括号跟随语句之后，不另起一段。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不使用</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3.2块语句的空格问题</strong><br>个人喜欢并自我强制使用左圆括号左、右圆括号右加空格<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>（四）、变量、函数及运算符</strong><br><strong>4.1变量声明</strong><br>因为会有变量提升的现象，浏览器在执行一个函数时首先定义了这个函数内的变量名，并且赋值undefied。所以我们在函数内定义的变量都可以提前写在函数内的开头，并且使用单var模式。</p>
<p><strong>4.2函数声明</strong><br>函数声明也有提升的现象，所以执行写在定义之前也是行的，但规范来讲函数的定义最好是在变量定义完之后跟上。而且函数定义不要在条件语句中出现。</p>
<p><strong>4.3相等</strong><br>当执行==操作时，js会将一方的值强制转换成与另一方数据类型相等，然后进行比较。<br>eg：”1” == 1<br>1 == true<br>0 == false<br>true会被转换成1<br>所以想进行比较的时候用<code>===</code>，不会进行数据类型的转换。</p>
<h3 id="第二部分_编程实践">第二部分 编程实践</h3><hr>
<p><strong>（五）、UI层的松耦合</strong><br>这章主要讲的是UI层三要素<code>html css jacascript</code>之间如何尽量消除耦合。</p>
<ul>
<li>html html文档中不要出现style内嵌css属性，也不要出现内嵌的js，比如onclick。</li>
<li>css css中不允许出现表达式内嵌javascript</li>
<li>javascript中尽量不要出现直接操作css的语句，改而用<code>className</code>代替，另外javascript尽量不要拼接html操作dom，改而使用客户端模板引擎或者后端直接吐一整段html出来。</li>
</ul>
<p>总结：个人平时使用中，其他几点基本都能做到，但在javascript中还是经常去拼接一些html，在以后的工作中，尽量用前端模板引擎代替。</p>
<p><strong>（六）、避免使用全局变量</strong></p>
<blockquote>
<p>在整个工程下使用全局变量，很容易覆盖掉别人写的一些变量，或者是自己定义的变量被别人错误的覆盖。</p>
</blockquote>
<p>一些解决办法：</p>
<p>1、命名空间<br>可以在全局window变量下自定义一个全局变量，而且这个全局变量具有很大的辨识度，不会覆盖掉浏览器的api。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> nanyangTask</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后所有的方法属性全部定义在这个全局变量之下。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nanyangTask.book = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、模块加载<br>模块是一种通用的代码片段，存放在一个表示执行一个任务或发布一个接口的单函数中，这些代码片段不会影响到全局变量。<br>公司中使用的seajs遵循cmd规范，在define()全局函数中写逻辑代码就可。</p>
<p>3、自执行函数，在自执行函数中定义的方法只要都带上var就不会污染全局变量，在不要给抛出接口的一些代码片段比较适合使用这种方式，比如现在在公司的活动营销页面的制作。</p>
<p><strong>（七）、事件处理</strong><br><strong>7.2隔离应用逻辑</strong><br>先来看一段平时写的很多的时间绑定逻辑<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span><span class="params">(ev)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">'X'</span>);</span><br><span class="line">	a.style.left = ev.clientX + <span class="string">'px'</span>;</span><br><span class="line">&#125;</span><br><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'click'</span>, handleClick);</span><br></pre></td></tr></table></figure></p>
<p>handleClick方法中的逻代码片段是一段应用逻辑，跟业务逻辑紧密相关，但是设想一下，现在的逻辑是在页面中点击一下，元素移动到鼠标的位置，但是还有一处业务逻辑是长按一下，元素移动到鼠标的位置。如此就要复制一段代码。所以我们要做的就是将应用的逻辑抽离出来。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span><span class="params">(ev)</span> </span>&#123;</span><br><span class="line">	moveBox(ev)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveBox</span><span class="params">(ev)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">'X'</span>);</span><br><span class="line">	a.style.left = ev.clientX + <span class="string">'px'</span>;</span><br><span class="line">&#125; </span><br><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span><span class="params">(ev)</span> </span>&#123;</span><br><span class="line">	handleClick(ev)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如此一来，moveBox方法就可以在多个地方调用。</p>
<p><strong>7.3不要分发事件对象</strong><br>上面的7.2还是有一些不好的地方，event事件对象被分发了很多次，首先传到事件处理程序handleClick，再传到应用逻辑函数moveBox，实际上应用逻辑是有很明确的目的的，这代表了这个方法会用到事件对象的哪些属性。所以修改下代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span><span class="params">(ev)</span> </span>&#123;</span><br><span class="line">	moveBox(ev.clientX);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveBox</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">'X'</span>);</span><br><span class="line">	a.style.left = x + <span class="string">'px'</span>;</span><br><span class="line">&#125; </span><br><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span><span class="params">(ev)</span> </span>&#123;</span><br><span class="line">	handleClick(ev)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这样做的好处是应用逻辑可以明确知道是干什么的，并且这样方便了测试，测试时不需要模拟事件，直接调用<code>moveBox(10)</code>就好了。<br>另外对于事件处理程序的一些方法，比如阻止默认事件，阻止冒泡都写在事件处理程序<code>handleClick</code>中，进一步分离事件处理程序和应用逻辑。</p>
<p><strong>（八）、避免空比较</strong><br><strong>8.1检测原始值</strong><br>javascript有5种原始值 </p>
<ul>
<li>number</li>
<li>string</li>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
</ul>
<p>检测number、string、boolean、endefined四种数据类型使用<code>typeof</code>非常实用也安全，返回的就是这四种类型。<br>null一般不用于检测，除非某个返回值就是null，例如document.getElementById(‘#rff’);如果没有这个 节点，返回的就是null。</p>
<p><strong>8.2检测引用值</strong><br>引用类型包括数组、对象、函数等除了原始值之外的数据类型。<br>typeof检测这些类型返回的都是object。<br>所以检测引用类型的方法可以用instanceof<br>[] isstanceof Array === true</p>
<p>最新方法：<br>Object.prototype.toString().call(value) === “[object Array]”  </p>
<p><strong>8.3判断对象的属性是否存在</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">object</span> = &#123;</span><br><span class="line">	arrd: <span class="string">'d'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>in if ( ‘arrd’ in object ) {}</li>
<li>hasOwnProperty  if (object hasOwnProperty ‘arrd’) {}<br>两者的区在在于，in检测arrd这个属性是否是这个object实例的，但如果是其原型上的属性，也返回true，但hasOwnProperty只检测是否是实例的属性。</li>
</ul>
<p><strong>（九）、将配置数据从代码中分离出来</strong><br><strong>9.1什么是配置数据</strong><br>简单来讲就是在js逻辑里定死的数据，只能通过人为的去改的数据<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">size</span> &gt; <span class="number">90</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面一段代码中，MAX_SIZE就是一个配置数据，在代码中固定。</p>
<p><strong>9.2抽离配置数据</strong><br>将js逻辑代码里的配置数据都抽离出来存放在config对象中去。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> config = &#123;</span><br><span class="line">	MSG_INVALID_VALUE: <span class="string">'Invalid value'</span>,</span><br><span class="line">	URL_INVALID: <span class="string">'XXX'</span>,</span><br><span class="line">	CSS_APP: <span class="string">'select'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>规范下，配置数据即定数据采用全大写的方式，首单词标明了这个数据的类型。</p>
<p><strong>（十一）、不是你的对象不要动</strong><br>简单来讲，就是处理自己的逻辑代码，绝不尝试修改，覆盖，删除window的属性方法，绝不Object原型上的方法属性，或者是自己同事的代码。</p>
<p><strong>（十二）、浏览器嗅探</strong><br><strong>12.1user-agent</strong><br>处理兼容性上这是最后的办法，会由很大的不准确性，真的要检测useragent也要首先检测旧版本，并进行一些hack，else的情况执行正常的逻辑代码。</p>
<p><strong>12.2特性检测</strong><br>特性检测并不是去检测是什么浏览器，因为对于某些特性，会有多个浏览器支持。<br>正确的特性检测的一些重要组成部分</p>
<ul>
<li>探测标准的方法</li>
<li>探测不同浏览器的特定方法。</li>
</ul>
<p><strong>值得注意的是千万不要根据特性去判断是什么浏览器</strong><br>比如</p>
<blockquote>
<p>var isIE = !!documenr.all 现在docuemnt.all是ie的特型，但是不应该通过这个特型去决定是否是一个浏览器，因为，假如哪天ie删除了这个属性，而isIE这个变量又大量用于文件中，会引起很多问题。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/11/15/编写可维护的javascript阅读笔记/" data-id="ciifddu0x0004kgwlavighwz7" class="article-share-link" data-share="baidu">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/书籍阅读/">书籍阅读</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-破译关键渲染路径（翻译）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/12/破译关键渲染路径（翻译）/" class="article-date">
  <time datetime="2015-11-11T16:20:25.000Z" itemprop="datePublished">2015-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/12/破译关键渲染路径（翻译）/">破译关键渲染路径（翻译）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="破译关键渲染路径（翻译）">破译关键渲染路径（翻译）</h2><p>英文来源：<a href="http://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/" target="_blank" rel="external">http://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/</a><br>参考：<a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/analyzing-crp" target="_blank" rel="external">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/analyzing-crp</a><br><strong>translated by 南洋</strong></p>
<h3 id="前言_By_南洋">前言 By 南洋</h3><p>最近在研究页面性能监控的事情，得知HTML5的 <code>Navigation Timing API</code>可以获取到一系列加载的关键时间节点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">'use strict'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`performance.timing.domInteractive: <span class="subst">$&#123;performance.timing.domInteractive&#125;</span>`</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`performance.timing.domContentLoadedEventStart: <span class="subst">$&#123;performance.timing.domContentLoadedEventStart&#125;</span>`</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`performance.timing.domContentLoadedEventEnd: <span class="subst">$&#123;performance.timing.domContentLoadedEventEnd&#125;</span>`</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`performance.timing.domComplete: <span class="subst">$&#123;performance.timing.domComplete&#125;</span>`</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`performance.timing.loadEventStart: <span class="subst">$&#123;performance.timing.loadEventStart&#125;</span>`</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`performance.timing.loadEventEnd: <span class="subst">$&#123;performance.timing.loadEventEnd&#125;</span>`</span>)</span><br></pre></td></tr></table></figure></p>
<p>将这些代码拷贝到console中，就可以看到加载过程中的部分数据，或直接查看<code>performance.timing</code> 我暂时为监控安排的数据为</p>
<ul>
<li>白屏时间</li>
<li>用户可交互时间</li>
<li>总加载时间</li>
<li>首屏时间</li>
</ul>
<p>白屏时间跟总加载时间暂时可以在这个API直接获得，有分歧的是用户可交互时间，不知道怎么通过这个API取得，在阅读了上面这篇文章后就悟了。</p>
<p><strong>在文档中只存在异步脚本的不适用</strong><br><code>interactingTime(用户可交互时间) = timing.domContentLoadedEventEnd - timing.navigationStart</code></p>
<p>另外需要提前说明的是：在下文中出现了一张浏览器加载过程中的路径图，上面的的各种英文代表的是document的状态，什么时间点，浏览器完成了什么事，状态就会相应的改变，而下文中经常提到的<code>DOMContentLoaded（DCL）</code>跟<code>window.onload</code>类似，是事件，当document的状态相应变化时，就会触发相应的事件。而图中的<code>performance.timing.domContentLoadedEventStart</code>与<code>performance.timing.domContentLoadedEventEnd</code>之差就代表了<code>DOMContentLoaded</code>事件执行的时间。同理<code>performance.timing.loadEventStart</code>与<code>performance.timing.loadEventEnd</code>之差代表了<code>onload</code>事件执行的时间。</p>
<h3 id="正文开始">正文开始</h3><p>正如steve在先前的文章中提到的，window.onload不是测量网站速度的最好方法。这个方法是最方便的也是最熟悉的，但是这并不能够获得一些现代页面的一些动态速度信息。我们想象用户能察觉到页面的一种表现：页面开始加载后多久后用户能跟页面进行交互？<br>交互的定义取决于你的页面，对于有些页面我们能获得可见的字就算是交互，而对于另外一些页面，写了狠多的js组件去构建UI（类似Gmail）。对于这两种例子，他们有一个共同点，那就是用户必须能看见的这个页面，换句话来讲就是浏览器需要呈现什么东西到屏幕上。<br>带着这个问题我们来探究一下，当第一批内容呈现在现代浏览器上的时候，到底发生了什么事情。</p>
<h3 id="DOM_+_CSSOM_=_Render_Tree">DOM + CSSOM = Render Tree</h3><p>渲染管道的准确时间点和行为当然会取决于解析（parsing）布局（layout）还有一些管道的结合，抛开不同点来讲，为了得到一些可见的东西在屏幕上，所有浏览器必须要构建什么东西到渲染书（render tree）<br><img src="http://chuantu.biz/t2/22/1450664869x1822611278.png" alt="Alt text"><br>HTML文档的解析构建成了DOM树，在平行空间里有一个被遗忘了的兄弟—-CSSOM，CSSOM是有一些样式规则和样式资源所构建的，DOM树和CSSOM结合构成渲染树（render tree）。这时标明了浏览器有足够的信息区形成布局然后绘制在屏幕上，到目前为止，一切顺利。<br>然而，上图的例子是最乐观的，CSSOM和DOMtree相安无事的在两个平行空间里被构建。接下来很不幸的我将介绍我们最爱的朋友—javascript。</p>
<ul>
<li>同步的javascript可以改些文档在任何节点，因此DOMtree 一旦碰上script标签就会停止构建</li>
<li><strong>javascript能查询dom对象的可被计算的样式，这意味着js可以阻塞css</strong></li>
</ul>
<p><img src="http://chuantu.biz/t2/22/1450665095x-954498918.png" alt="Alt text"></p>
<p>不像上面那种DOM和CSSDOM相安无事的个子构建，现在两者潜在地互相牵制：DOMtree无法构建直到javascript被执行，javascript无法执行直到CSSOM是可行的，Yikes。。。</p>
<p>Depending on how this dependency graph is resolved on your pages, which is governed by how, and how many resources you include in that first “critical path” of the page load, the time to first render will vary accordingly. Can we get some metrics, or insights into this process? Turns out, yes we can!</p>
<h3 id="Document_Interactive_&amp;_DOMContentLoaded">Document Interactive &amp; DOMContentLoaded</h3><p>HTML5 定义了一系列浏览器从开始工作请求http到呈现页面必须执行的规则well documented sequence of steps.<br><img src="http://7xpcne.com1.z0.glb.clouddn.com/3%20(2).png" alt="Alt text"></p>
<p><strong>浏览器加载关键路径图</strong><br>特别的，一系列步骤的较后方两个步骤能解决我们最开始提到的问题。在页面最开始的最开始的内容的出现之前，到底发生了什么事。</p>
<ul>
<li>document被标记为interactive状态，当浏览器结束DOMtree的构建，标明，DOMtree准备好了。</li>
<li>一旦任何标有defer的script标签被执行了，浏览器就会触发了DOMContentLoaded事件，这个时候没有样式文件阻塞了脚本的执行（我注：当然这个script标签是在interactive状态之后的，如果没有表有defer的script，一旦document的状态变成interactive，就会触发DOMContentLoaded事件。）</li>
</ul>
<p>如果没有同步的javascript在文档中，那么DOMtree很CSSOM的构建会平行的进行，当我们将javascript请入的时候事情会变的有趣很多。</p>
<p>如果你给一个同步脚本加上<code>defer</code>，那么这个脚本就会解除对DOMtree构建的阻塞，document的<code>interactive</code>状态不会等待脚本的执行就会开启，值得注意的是，这个相同的脚本会在DOMContentLoaded事件触发之前执行。然后脚本开始执行，简而言之，给脚本加<code>defer</code>，脚本不会阻塞<code>document interactive</code>这个状态了，但是依然会组织DCL事件的触发。(自注：defer执行的时间)</p>
<p>如果你给一个同步脚本加上<code>async异步</code>，CSSOM不会阻塞脚本的执行了，最重要的一个区别，DCL事件的触发不需要等待异步脚本的执行！<br>（自注：这就意味着DCL事件的触发不需要等待CSSOM的完成，此时的现象就跟Develop文档里的第一段解释一样了，同样，这个现象也符合文档中没有脚本的情况<a href="https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded</a><br><code>The DOMContentLoaded event is fired when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading.</code>）</p>
<p>第一个关键点：默认情况下，javascript会阻塞DOMtree的构建，也许是被CSSOM构建花费时间的阻塞（自注：CSSOM的构建导致javascript的阻塞，从而导致DOMtree的构建）。同步的脚本很坏，但是我们早就知道，让脚本加上<code>defer</code>/<code>async</code>相当于对解析器做了个保证，这些脚本不会重写dom，故而被放行。</p>
<p>第二个关键点： 如果在某种情况下我们必须要等待脚本的执行，我们首先要让CSSOM构建完毕。换句话说，javascript跟css之间有严重的依赖关系。。。。样式在上，脚本在下，现在知道原因了？</p>
<p>好了！理论固然重要，但是这些抽象的知识能帮助我们优化页面速度吗？balabala。。废话。。（理论是基础）</p>
<h3 id="沿着你的页面的关键路劲">沿着你的页面的关键路劲</h3><p>如果不出意外，监控<code>documenr interactive</code>状态，会给我们很好的一个指示：我们是否因为同步的脚本阻塞了DOMtree的构建，有时候测量这个阻塞的行为没有其他办法了，所以监控<code>interactive</code>状态会是一个折中的好办法。</p>
<p>而DCL事件（domContentLoaded）也是个关键的指标，许多著名的库，类似<code>jquery</code>，在触发这个事件后开始执行他们的代码，换句话说，这可能是用户能跟页面交互的一个开始时间节点，而在这个事件中的回调，也是在这个事件触发后发给用户。如果你做对了工作，通过逐步的提高，你可以让页面的速度加快，因此用户可以跟页面交互而浏览器继续加载剩余的资源（img等）。IE团队有一个绝佳的例子演示了DCL与<code>window.onload</code>的不同。<br><a href="http://ie.microsoft.com/testdrive/HTML5/DOMContentLoaded/Default.html" target="_blank" rel="external">http://ie.microsoft.com/testdrive/HTML5/DOMContentLoaded/Default.html</a></p>
<p>完。</p>
<p>完。</p>
<p>—<br>原创文章，转载请注明出处！</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/11/12/破译关键渲染路径（翻译）/" data-id="ciifddu100009kgwl9gae3hpg" class="article-share-link" data-share="baidu">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端性能监控/">前端性能监控</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-attribute与property" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/12/attribute与property/" class="article-date">
  <time datetime="2015-10-12T14:42:58.000Z" itemprop="datePublished">2015-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/12/attribute与property/">attribute与property</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Dom节点Attribute与Property">Dom节点Attribute与Property</h2><blockquote>
<p>前段时间在尚妆请假OA系统中接触到了大量<code>checkbox/select/input</code>等表单元素，在使用jq的attr遇到了一些问题，所以了解了一下这几者的关系，顺便理了理dom的一些基础。</p>
</blockquote>
<p>1、在IE&lt;9中,浏览器会把所有的property和attribute强制映射，即property = attribute<br>tip：通过getAttribute获取到的值都是字符串，<br>但通过property获取的值可以是任何类型。</p>
<p>2、每个dom节点都是一个对象，既然是js对象，就跟对象一样式是有属性和方法的。而且原则上这些属性方法都是在js中出现供js调用的。但是不同的节点总会有几个默认的常见的属性出现在html上（不是页面上,是指在查看控制台中的element），比如a标签的<code>href</code>，img标签的<code>src</code>，以及多数标签的<code>id</code>。<br>当然方法也是可以出现在html上的，比如<code>onclick onblur等</code><br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">list</span> = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> document.body) &#123;</span><br><span class="line">	<span class="keyword">list</span>.push(key)</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="literal">log</span>(<span class="keyword">list</span>.join('\<span class="keyword">n</span>'))</span><br><span class="line"><span class="comment">//这个方法可以在控制台查看某个dom对象的所有属性跟方法。</span></span><br></pre></td></tr></table></figure></p>
<p>3、而出现在html中的属性在dom中（不是对象）就不叫<code>property</code>了，而叫<code>attribute</code>。<br><code>property</code>和<code>attribute</code>存在<strong>某种程度上</strong>的映射关系，即改变其中之一，相对应的也会改变。</p>
<p>4、property跟attribute的读写方式不同，<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);</span><br><span class="line"><span class="comment">//property</span></span><br><span class="line">》<span class="literal">get</span> a.id;</span><br><span class="line">》<span class="literal">set</span> a.id = <span class="string">'es'</span>;</span><br><span class="line"><span class="comment">//attribute</span></span><br><span class="line">》<span class="literal">get</span> a.getAttribute(<span class="string">'id'</span>)</span><br><span class="line">》<span class="literal">set</span> a.setAttribute(<span class="string">'id'</span>, <span class="string">'es'</span>);</span><br></pre></td></tr></table></figure></p>
<p>5、既然第四点内容里对于两种属性都有读写，那改变了其中一个（例如property），另一个属性会不会也改呢？接下来就来解释一下，这里面有一些特殊的点，记住就好。</p>
<p>property属性非常多，而attribute并不多，常用的有<code>name, id, scr, href, value, checked等</code></p>
<ul>
<li>对于这些attribute属性，通过setAttribute改变值时，都能同步到property上（即改变了attribute，htmldom直接显示改了， 然后去dom节点对象里查看property也变了）</li>
<li>而通过第4点中的property<code>a.id</code>写方法，对于<code>value、checked</code>属性来说，并不改变相对应的attribute的值。这也意味着改了property，但html中的value值却不变。</li>
<li><strong>但是</strong>： 对于input中的value和checked这两个属性来讲，property获取的是页面的显示，而attribute获取的是html中的属性值。</li>
<li>所以用户在输入框中输入，我们在js中要获取到就要使用property。</li>
<li>特别说明checkbox的property属性是checked = true，checkbox = false。而在html中写attribute时若要初始勾选就</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="class"><span class="keyword">type</span></span>=<span class="string">"checkbox"</span> id=<span class="string">"checkbox"</span> checked&gt;</span><br></pre></td></tr></table></figure>
<p>6、还有个select表单元素的value属性，对于select元素而言，一般没有value的attribute属性，而property获取到的就是选中的下拉框option的value属性。<br>而对于option元素，其value的attribute和property属性都只指向html中的value值，不会涉及到<strong>s或a</strong>这些显示在页面上的值，这点不要跟input的输入框混淆了。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">select</span> <span class="attribute">id</span>=<span class="value">"select"</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">"22"</span>&gt;</span>s<span class="tag">&lt;/<span class="title">option</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">"1"</span>&gt;</span>a<span class="tag">&lt;/<span class="title">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">select</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>综上所述</strong>：除了input中的type=text的value和type=checkbox的checked属性外，其他属性用property和attribute差别不大。但是对于value和checked还是使用property比较方便，因为我们大多数都是想获取到用户输入了什么。对应到jq中就是使用其prop()方法。</p>
<p>还有二个特殊的属性，在映射中名字不一样。</p>
<blockquote>
<p>attribute   &lt;==&gt; property</p>
</blockquote>
<ol>
<li>class  &lt;==&gt;  className</li>
<li>data-x  &lt;==&gt;  dataset.x</li>
</ol>
<p>这两个属性都是互通的。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/10/12/attribute与property/" data-id="ciifddu1w001jkgwl7q5zw14y" class="article-share-link" data-share="baidu">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-tween" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/05/tween/" class="article-date">
  <time datetime="2015-10-05T15:24:45.000Z" itemprop="datePublished">2015-10-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/动画库/">动画库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/05/tween/">tweenMax基础api的逐条随意翻译</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="tweenMax基础api的逐条随意翻译">tweenMax基础api的逐条随意翻译</h3><p><code>1</code>tween没有内置的选择器引擎，在没有载入jquery等类库的情况下只能通过<code>getElementById</code>进行选择。<br><code>2.ticker</code><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TweenMax.ticker.addEventListener(<span class="string">"tick"</span>, myFunction);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span><span class="params">(event)</span> </span>&#123;</span><br><span class="line"><span class="comment">//executes on every tick after the core engine updates</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>3.delay()</code><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> currentDelay</span> = myAnimation.delay(); <span class="comment">//gets current delay</span></span><br><span class="line">myAnimation.delay(<span class="number">2</span>); <span class="comment">//sets delay</span></span><br></pre></td></tr></table></figure></p>
<p>dalay方法可以设置或者获取某一个实例的延迟。<br>数值是以秒为单位的。<br>在设置了延迟的tween中，一切开始的动画都在delay之后开始，除了from()方法，from方法是不管延迟的，直接开始，除非设置了immediateRender:false参数在vars对象里。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TweenMax ( <span class="string">target:</span>Object, <span class="string">duration:</span>Number, <span class="string">vars:</span>Object ) ;</span><br><span class="line"><span class="comment">//就是设置运动参数的vars对象。</span></span><br></pre></td></tr></table></figure></p>
<p><code>4.TweenMax.delayedCall()</code><br>定义一个实例，这个实例表示延迟了多少秒后调用一个函数，而且回调函数可以传参数，<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//calls myFunction after 1 second and passes 2 parameters:</span></span><br><span class="line">TweenMax.delayedCall(<span class="number">1</span>, myFunction, [<span class="string">"param1"</span>, <span class="string">"param2"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span><span class="params">(param1, param2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//do stuff</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//即如果这个方法写在文档加载后，即代表文档加载后过1秒执行myFunction函数，并且可以传一个数组的参数进去</span></span><br></pre></td></tr></table></figure></p>
<p><code>5.duration(time)</code><br>获取tween实例的动画时长或者设置其动画时长<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> currentDuration <span class="subst">=</span> myAnimation<span class="built_in">.</span><span class="built_in">duration</span>(); <span class="comment">//gets current duration</span></span><br><span class="line">myAnimation<span class="built_in">.</span><span class="built_in">duration</span>(<span class="number">2</span>); <span class="comment">//sets duration</span></span><br></pre></td></tr></table></figure></p>
<p><code>6.endTime()</code><br>只返回tween实例结束动画的时间<br><code>7.eventCallback( type:String, callback:Function, params:Array, scope:* )</code><br>作用跟在tween的vars对象里直接写上事件是一样的，区别是这样做可以解除这个事件的绑定。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//the following two lines produce IDENTICAL results:</span></span><br><span class="line">var myAnimation = <span class="keyword">new</span> TweenLite(mc, <span class="number">1</span>, &#123;<span class="string">x:</span><span class="number">100</span>, <span class="string">onComplete:</span>myFunction, <span class="string">onCompleteParams:</span>[<span class="string">"param1"</span>,<span class="string">"param2"</span>]&#125;);</span><br><span class="line">myAnimation.eventCallback(<span class="string">"onComplete"</span>, myFunction, [<span class="string">"param1"</span>,<span class="string">"param2"</span>]);</span><br></pre></td></tr></table></figure></p>
<p>如果要给一个tween实例绑定不同的多个事件，则可以<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myAnimation.<span class="function"><span class="title">eventCallback</span><span class="params">(<span class="string">"onComplete"</span>, completeHandler)</span></span>.<span class="function"><span class="title">eventCallback</span><span class="params">(<span class="string">"onUpdate"</span>, updateHandler, [<span class="string">"param1"</span>,<span class="string">"&#123;self&#125;"</span>])</span></span></span><br><span class="line"><span class="comment">//链式调用</span></span><br></pre></td></tr></table></figure></p>
<p>如何解除绑定<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//deletes the onUpdate</span></span><br><span class="line">myAnimation.eventCallback(<span class="string">"onUpdate"</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>需要注意的是一个事件只能有一个callback，如果写多个callback那将会覆盖</strong><br><code>8、TweenMax.fromTo( target:Object, duration:Number, fromVars:Object, toVars:Object )</code><br>需要注意的是一般的vars的属性写在fromVars里，而特殊的类似onComplete等方法需要写在toVars对象里。<br><code>9、TweenMax.getAllTweens( includeTimelines:Boolean ) : Array</code><br>返回一个数组，包含所以的tween实例，参数可以选择是否返回timeline实例，如果想要实现对所有的实例同意操作，比如暂停，开始等，可以考虑使用<code>TimelineLite.exportRoot()</code><br><code>10、TweenMax.getTweensOf( target:Object, onlyActive:Boolean );</code><br>在当前寻找到操作元素对象是Object的tween，并返回。也可能返回多个tween的数组.若onlyActive为true则只返回正在运行的tween。<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TweenMax.<span class="keyword">to</span>(myObject1, <span class="number">1</span>, <span class="comment">&#123;x:100&#125;</span>);</span><br><span class="line">TweenMax.<span class="keyword">to</span>(myObject2, <span class="number">1</span>, <span class="comment">&#123;x:100&#125;</span>);</span><br><span class="line">TweenMax.<span class="keyword">to</span>([myObject1, myObject2], <span class="number">1</span>, <span class="comment">&#123;opacity:0&#125;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1 = TweenMax.getTweensOf(myObject1); <span class="comment">//finds 2 tweens</span></span><br><span class="line"><span class="keyword">var</span> a2 = TweenMax.getTweensOf([myObject1, myObject2]); <span class="comment">//finds 3 tweens</span></span><br></pre></td></tr></table></figure></p>
<p><code>11、TweenMax.globalTimeScale( value:Number );</code><br>设置全部tween的速度，大于1则表示速度越大。<br><code>12、.invalidate()</code>不懂<br><code>13、.isActive( ) : Boolean</code><br>可以查看这个tween是否是在运动中，没开始，结束，暂停都不算在运动中。<br><code>14、TweenMax.isTweening(target: object)</code><br>Reports whether or not a particular object is actively tweening. If a tween is paused, is completed, or hasn’t started yet, it isn’t considered active.<br><code>15、.kill()</code><br>看下方官方给出的示例代码就能清楚的知道.kill()方法的用途<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// <span class="operator"><span class="keyword">kill</span> the entire animation:</span><br><span class="line">myAnimation.<span class="keyword">kill</span>();</span></span><br><span class="line"> </span><br><span class="line">//<span class="operator"><span class="keyword">kill</span> <span class="keyword">only</span> the <span class="string">"x"</span> <span class="keyword">and</span> <span class="string">"y"</span> properties <span class="keyword">of</span> the animation (<span class="keyword">all</span> targets):</span><br><span class="line">myAnimation.<span class="keyword">kill</span>(&#123;x:<span class="literal">true</span>, y:<span class="literal">true</span>&#125;);</span></span><br><span class="line"> </span><br><span class="line">//<span class="operator"><span class="keyword">kill</span> <span class="keyword">all</span> parts <span class="keyword">of</span> the animation related <span class="keyword">to</span> the target <span class="string">"myObject"</span> (<span class="keyword">if</span> the tween has multiple targets, the others will <span class="keyword">not</span> be affected):</span><br><span class="line">myAnimation.<span class="keyword">kill</span>(<span class="literal">null</span>, myObject);</span></span><br><span class="line"> </span><br><span class="line">//<span class="operator"><span class="keyword">kill</span> <span class="keyword">only</span> the <span class="string">"x"</span> <span class="keyword">and</span> <span class="string">"y"</span> properties <span class="keyword">of</span> animations <span class="keyword">of</span> the target <span class="string">"myObject"</span>:</span><br><span class="line">myAnimation.<span class="keyword">kill</span>(&#123;x:<span class="literal">true</span>, y:<span class="literal">true</span>&#125;, myObject);</span></span><br><span class="line">  </span><br><span class="line">//<span class="operator"><span class="keyword">kill</span> <span class="keyword">only</span> the <span class="string">"opacity"</span> properties <span class="keyword">of</span> animations <span class="keyword">of</span> the targets <span class="string">"myObject1"</span> <span class="keyword">and</span> <span class="string">"myObject2"</span>:</span><br><span class="line">myAnimation.<span class="keyword">kill</span>(&#123;opacity:<span class="literal">true</span>&#125;, [myObject1, myObject2]);</span></span><br></pre></td></tr></table></figure></p>
<p><code>16、TweenMax.killAll( complete:Boolean, tweens:Boolean, delayedCalls:Boolean, timelines:Boolean );</code><br><code>17、TweenMax.killChildTweensOf( parent:Object, complete:Boolean );</code><br>去除父元素下的所有tween，可选的complete若为true则先完成动画 再kill。<br><code>18、TweenMax.lagSmoothing()</code>不懂<br><code>19、.pause( atTime:*, suppressEvents:Boolean ) : *</code><br>如果括号内有秒计数的数字，则表示运动到atTime秒后在暂停<br><code>20、TweenMax.pauseAll( tweens:Boolean, delayedCalls:Boolean, timelines:Boolean );</code><br>括号内可选的属性的默认值都是true 表示默认暂停这些所有<br><code>21、paused(boolean)</code><br>getter or setter 判断当前tween实例是否处于停止状态。<br>下方代码的toggles比较有用<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var paused = myAnimation.paused(); //gets current paused <span class="keyword">state</span></span><br><span class="line">myAnimation.paused( true ); //sets paused <span class="keyword">state</span> <span class="keyword">to</span> true (just like pause())</span><br><span class="line">myAnimation.paused( !myAnimation.paused() ); //toggles the paused <span class="keyword">state</span></span><br></pre></td></tr></table></figure></p>
<p><code>22、play(from:num, suppressEvents:Boolean)</code><br>from值默认情况下是在元素当前的位置开始动。设置的数值代表直接从第几分钟开始运动<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//begins playing from wherever the playhead currently is:</span></span><br><span class="line">myAnimation.<span class="keyword">play</span>();</span><br><span class="line"><span class="comment">//begins playing from exactly 2-seconds into the animation:</span></span><br><span class="line">myAnimation.<span class="keyword">play</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//begins playing from exactly 2-seconds into the animation but doesn't suppress events during the initial move:</span></span><br><span class="line">myAnimation.<span class="keyword">play</span>(<span class="number">2</span>, false);</span><br></pre></td></tr></table></figure></p>
<p><code>23、.progress( value:Number, suppressEvents:Boolean )</code><br>指示tween跳转到进程的某一个阶段（0-1），比如0.5就代表跳到进程的一半。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> progress</span> = myTween.progress(); <span class="comment">//gets current progress</span></span><br><span class="line">myTween.progress( <span class="number">0.25</span> ); <span class="comment">//sets progress to one quarter finished</span></span><br></pre></td></tr></table></figure></p>
<p><code>24、.repeat( value:Number )</code><br>可以写在vars对象里<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">repeat</span> = myTween.<span class="built_in">repeat</span>(); //gets current <span class="built_in">repeat</span> value&lt;<span class="keyword">br</span> /&gt;</span><br><span class="line">myTween.<span class="built_in">repeat</span>(<span class="number">2</span>); //sets <span class="built_in">repeat</span> <span class="keyword">to</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p><code>25、.repeatDelay( value:Number )</code><br>延迟几秒再重复<br>可以写在vars对象里<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">TweenMax</span><span class="class">.to</span>(mc, <span class="number">1</span>, &#123;<span class="attribute">x</span>:<span class="number">100</span>, <span class="attribute">repeat</span>:<span class="number">2</span>, <span class="attribute">repeatDelay</span>:<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>也可以当方法写<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> repeatDelay</span> = myTween.repeatDelay(); <span class="comment">//gets current repeatDelay value</span></span><br><span class="line">myTween.repeatDelay(<span class="number">2</span>); <span class="comment">//sets repeatDelay to 2</span></span><br></pre></td></tr></table></figure></p>
<p><code>26、.restart( includeDelay:Boolean, suppressEvents:Boolean )</code><br>第一个参数表示是否包含上一次的延迟效果，如果为true，则表示重复的时候还有继承上一次的延迟，即触发的时候会延迟几秒再开始动作。<br><code>27、.reverse( from:*, suppressEvents:Boolean )</code><br>往相反的方向运动，如果将值设置为0，则从先前运动的最后时刻开始往反方向运动。如果是-1，则跳到距离终点还有1秒的时刻开始掉头运动。<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reverses playback from wherever the playhead currently is:</span></span><br><span class="line"> myAnimation.<span class="keyword">reverse</span>();</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//reverses playback from exactly 2 seconds into the animation:</span></span><br><span class="line"> myAnimation.<span class="keyword">reverse</span>(<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//reverses playback from exactly 2 seconds into the animation but doesn't suppress events during the initial move:</span></span><br><span class="line">myAnimation.<span class="keyword">reverse</span>(<span class="number">2</span>, <span class="keyword">false</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//reverses playback from the very END of the animation:</span></span><br><span class="line">myAnimation.<span class="keyword">reverse</span>(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//reverses playback starting from exactly 1 second before the end of the animation:</span></span><br><span class="line">myAnimation.<span class="keyword">reverse</span>(-<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//flips the orientation (if it's forward, it will go backward, if it is backward, it will go forward):</span></span><br><span class="line"><span class="keyword">if</span> (myAnimation.reversed()) &#123;</span><br><span class="line">    myAnimation.play();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    myAnimation.<span class="keyword">reverse</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//flips the orientation using the reversed() method instead (shorter version of the code above):</span></span><br><span class="line">myAnimation.reversed( !myAnimation.reversed() );</span><br></pre></td></tr></table></figure></p>
<p><code>28、.reversed( value:Boolean )</code><br>判断是否在相反的方向，用法跟pasued()一样<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> rev</span> = myAnimation.reversed(); <span class="comment">//gets current orientation</span></span><br><span class="line">myAnimation.reversed( <span class="literal">true</span> ); <span class="comment">//sets the orientation to reversed</span></span><br><span class="line">myAnimation.reversed( !myAnimation.reversed() ); <span class="comment">//toggles the orientation</span></span><br></pre></td></tr></table></figure></p>
<p><code>29、TweenMax.set( target:Object, vars:Object )</code><br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">TweenMax</span><span class="class">.set</span>(myObject, &#123;<span class="attribute">x</span>:<span class="number">100</span>, <span class="attribute">y</span>:<span class="number">50</span>, <span class="attribute">opacity</span>:<span class="number">0</span>&#125;);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="tag">TweenMax</span><span class="class">.to</span>(myObject, <span class="number">0</span>, &#123;<span class="attribute">x</span>:<span class="number">100</span>, <span class="attribute">y</span>:<span class="number">50</span>, <span class="attribute">opacity</span>:<span class="number">0</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>30、.time()</code><br>获取或设置tween的当前运动的时间点<br><code>30、.timeScale()</code><br>获取或设置当前tween的速度缩放数值</p>
<p>原整理文章，转载请注明出处！</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/10/05/tween/" data-id="ciifddu1l0012kgwla1c2vwcx" class="article-share-link" data-share="baidu">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jsLib/">jsLib</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hammer-js" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/05/hammer-js/" class="article-date">
  <time datetime="2015-10-05T15:24:45.000Z" itemprop="datePublished">2015-10-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/05/hammer-js/">hammerjs的初次学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="hammerjs的初次学习">hammerjs的初次学习</h2><h3 id="Hammer-js_手势库的学习与应用。">Hammer.js 手势库的学习与应用。</h3><blockquote>
<p>上个礼拜公司交代的任务中有一个需求，商品详细页面的图片点击后可以缩放拖拽。本来想用原生的api取写，但是出来的效果兼容性很差，在双击，拖拽，放大绑定在同一元素的情况下，很容易误触发不相关的动作，比如在双指缩放时一不小心就触发了双击事件，能力还未够，所以在hammer.js官网学习了一下手势库，完成了那个需求。</p>
</blockquote>
<p><strong>1、hammerjs概括</strong><br>hammerjs一共有6种手势，<code>pan</code>(拖拽)，<code>pinch</code>(缩放)，<code>press</code>(长按) <code>rotate</code>(旋转)  <code>swipe</code>(滑动) <code>tap</code>(点)。这6个手势几乎涵盖了所有日常所需！<br><strong>2、用法</strong><br>需要实例化一个对象。<br>我这里提供一个我在项目中使用的通用写法。<br>我们写移动端一般都包含zepto的底层工具库。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wrap = $(<span class="string">'.wrap'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//定义一个元素节点，注意这里不能是jq或者zepto对象</span></span><br><span class="line"><span class="keyword">var</span> wrapHammer = <span class="keyword">new</span> Hammer(wrap);</span><br><span class="line"><span class="comment">//把需要绑定事件的节点传入，实例化。</span></span><br><span class="line"><span class="keyword">var</span> singletap = <span class="keyword">new</span> Hammer.Tap();</span><br><span class="line"><span class="comment">//实例化手势对象</span></span><br><span class="line"><span class="keyword">var</span> doubletap = <span class="keyword">new</span> Hammer.Tap(&#123;<span class="keyword">event</span>: <span class="string">'doubletap'</span>, taps: <span class="number">2</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> pinch = <span class="keyword">new</span> Hammer.Pinch();</span><br><span class="line"><span class="keyword">var</span> pan = <span class="keyword">new</span> Hammer.Pan();</span><br><span class="line"><span class="keyword">var</span> swipe = <span class="keyword">new</span> Hammer.Swipe();</span><br></pre></td></tr></table></figure></p>
<p>在实例化手势对象的时候可以传参数，不同的手势对象有不同的参数可以选择。具体可以参考官网。<br>例如想看<code>pan</code>在实例化的时候可以填什么参数，可以查看<a href="http://hammerjs.github.io/recognizer-pan/" target="_blank" rel="external">http://hammerjs.github.io/recognizer-pan/</a> 。有一个框表示了传入的对象里可以填什么参数。<br><strong>这里比较特殊的是Tap</strong>，不同数量的点击，需要实例化不同的对象。<br><strong>接下来</strong><br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wrapHammer.<span class="built_ins">add</span>(singletap);</span><br><span class="line">wrapHammer.<span class="built_ins">add</span>(doubletap);</span><br><span class="line">			  singletap.requireFailure(doubletap);			doubletap.requireFailure(singletap);</span><br><span class="line">			  </span><br><span class="line">wrapHammer.<span class="built_ins">add</span>(pinch);</span><br><span class="line">wrapHammer.<span class="built_ins">add</span>(pan);</span><br><span class="line">wrapHammer.<span class="built_ins">add</span>(swipe)</span><br><span class="line">//在实例出来的节点对象上<span class="built_ins">add</span>上一步实例化的手势对象，此时一个节点上将绑定了很多手势。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wrapHammer.<span class="keyword">on</span>(<span class="string">'tap'</span>, hideWrap);</span><br><span class="line">wrapHammer.<span class="keyword">on</span>(<span class="string">'doubletap'</span>, doubleScale);</span><br><span class="line">wrapHammer.<span class="keyword">on</span>(<span class="string">'pinchmove'</span>, scaleImg);</span><br><span class="line">wrapHammer.<span class="keyword">on</span>(<span class="string">'pinchend'</span>, scaleEndImg);</span><br><span class="line">wrapHammer.<span class="keyword">on</span>(<span class="string">'panstart'</span>, moveStartImg);</span><br><span class="line">wrapHammer.<span class="keyword">on</span>(<span class="string">'panmove'</span>, moveImg);</span><br><span class="line">wrapHammer.<span class="keyword">on</span>(<span class="string">'panend'</span>, moveEndImg);</span><br><span class="line"><span class="comment">//第三步就是绑定事件了</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>第三步中的这些事件名，可以在官网上对应手势页面的events中找到。例如若要查看<code>pinch</code>则<br><a href="http://hammerjs.github.io/recognizer-pinch/" target="_blank" rel="external">http://hammerjs.github.io/recognizer-pinch/</a></p>
<p><strong>3、注意点</strong><br>紧跟以上三步，基本就能做出基本的手势页面了。<br>接下来再介绍几个需要特殊设置的地方。<br><code>1</code>如果想要缩放与旋转同时触发，即边旋转边缩放。可以<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pinch = new Hammer.Pinch();</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">rotate</span> = new Hammer.<span class="keyword">Rotate</span>();</span><br><span class="line">pinch.recognizeWith(<span class="keyword">rotate</span>);</span><br></pre></td></tr></table></figure></p>
<p>官网页面：<a href="http://hammerjs.github.io/recognize-with/" target="_blank" rel="external">http://hammerjs.github.io/recognize-with/</a><br><code>2</code>在doubletap时会在之前触发tap，此时可以设置<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">singleTap.requireFailure(doubleTap);</span><br></pre></td></tr></table></figure></p>
<p>如此设置后在触发tap后稍微有些许停顿，以触发double。<br><code>3</code>在官网或者网上经常看到<code>pan</code> <code>swipe</code> 在默认情况下只能水平移动，如果要开启还需要设置。但采用我上面的写法，就不需要设置了，默认情况下上下左右都是打开的。<br><a href="http://hammerjs.github.io/recognizer-pan/" target="_blank" rel="external">http://hammerjs.github.io/recognizer-pan/</a><br>direction的默认值是DIRECTION_ALL，而且在最下面的note也说明了当采用<code>new Hanmmer()</code>实例化就默认水平，而我们是<code>new Hammer.pan()</code> 实例化。<br><code>pinch</code>道理也同，不需要再配置就可以用了。<br><code>4</code>在<code>on</code>的事件绑定中回调的event返回，最常用的也就是<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ev<span class="class">.type</span></span><br><span class="line">ev<span class="class">.deltaX</span></span><br><span class="line">ev<span class="class">.deltaY</span></span><br><span class="line">ev.scale</span><br></pre></td></tr></table></figure></p>
<p>链接推荐：<br><a href="https://cdn.rawgit.com/hammerjs/hammer.js/master/tests/manual/visual.html" target="_blank" rel="external">https://cdn.rawgit.com/hammerjs/hammer.js/master/tests/manual/visual.html</a><br><a href="http://www.cnblogs.com/iamlilinfeng/p/4239957.html" target="_blank" rel="external">http://www.cnblogs.com/iamlilinfeng/p/4239957.html</a></p>
<p>原创文章，转载请注明出处！</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/10/05/hammer-js/" data-id="ciifddu1s001ckgwldr1x3a1n" class="article-share-link" data-share="baidu">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-lazyload-js源码学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/28/lazyload-js源码学习/" class="article-date">
  <time datetime="2015-09-27T16:59:55.000Z" itemprop="datePublished">2015-09-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/28/lazyload-js源码学习/">lazyload.js源码学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="lazyload-js源码学习">lazyload.js源码学习</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Lazy Load - jQuery plugin for lazy loading images</span><br><span class="line"> *</span><br><span class="line"> * Copyright (c) 2007-2013 Mika Tuupola</span><br><span class="line"> *</span><br><span class="line"> * Licensed under the MIT license:</span><br><span class="line"> *   http://www.opensource.org/licenses/mit-license.php</span><br><span class="line"> *</span><br><span class="line"> * Project home:</span><br><span class="line"> *   http://www.appelsiini.net/projects/lazyload</span><br><span class="line"> *</span><br><span class="line"> * Version:  1.8.5</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">($, window, document, undefined)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $<span class="built_in">window</span> = $(<span class="built_in">window</span>);</span><br><span class="line">    <span class="comment">//基于jquery/zepto定义插件方法 lazyload</span></span><br><span class="line">    $.fn.lazyload = <span class="function"><span class="keyword">function</span><span class="params">(options)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//this 指向了调用了lazyload得dom对象</span></span><br><span class="line">        <span class="comment">//一般是一个包含多个元素的对象</span></span><br><span class="line">        <span class="keyword">var</span> elements = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> $container;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span><br><span class="line">        * 定义了默认的配置对象</span><br><span class="line">        * 在定义配置对象的时候最好将冒号对其 这样有益于阅读</span><br><span class="line">        *</span><br><span class="line">        **/</span></span><br><span class="line">        <span class="keyword">var</span> settings = &#123;</span><br><span class="line">            <span class="comment">//起征点 图片在离屏幕什么地方开始load</span></span><br><span class="line">            threshold       : <span class="number">0</span>,</span><br><span class="line">            <span class="comment">//可见区域外 搜索x个图片后停止搜索</span></span><br><span class="line">            failure_limit   : <span class="number">0</span>,</span><br><span class="line">            event           : <span class="string">"scroll"</span>,</span><br><span class="line">            effect          : <span class="string">"show"</span>,</span><br><span class="line">            container       : <span class="built_in">window</span>,</span><br><span class="line">            data_attribute  : <span class="string">"original"</span>,</span><br><span class="line">            <span class="comment">//是否跳过看不见的图片load</span></span><br><span class="line">            skip_invisible  : <span class="literal">true</span>,</span><br><span class="line">            appear          : <span class="literal">null</span>,</span><br><span class="line">            load            : <span class="literal">null</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">        * function update</span><br><span class="line">        * update函数的作用是在滚动后者resize屏幕时判断图片在屏幕中得位置，并作一些判断</span><br><span class="line">        **/</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//遍历需要懒加载的图片，根据当前屏幕相对文档的距离跟图片相对文档的距离的比较，去处理图片。</span></span><br><span class="line">            elements.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> $<span class="keyword">this</span> = $(<span class="keyword">this</span>);</span><br><span class="line">                <span class="comment">//如果配置的是跳过看不见的图片 并且 这些图片设置隐藏 则跳出update方法</span></span><br><span class="line">                <span class="keyword">if</span> (settings.skip_invisible &amp;&amp; $<span class="keyword">this</span>.css(<span class="string">"display"</span>) === <span class="string">"none"</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ($.abovethetop(<span class="keyword">this</span>, settings) ||</span><br><span class="line">                    $.leftofbegin(<span class="keyword">this</span>, settings)) &#123;</span><br><span class="line">                        <span class="comment">/* Nothing. */</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!$.belowthefold(<span class="keyword">this</span>, settings) &amp;&amp;</span><br><span class="line">                    !$.rightoffold(<span class="keyword">this</span>, settings)) &#123;</span><br><span class="line">                        $<span class="keyword">this</span>.trigger(<span class="string">"appear"</span>);</span><br><span class="line">                        <span class="comment">/* if we found an image we'll load, reset the counter */</span></span><br><span class="line">                        counter = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">if</span> (++counter &gt; settings.failure_limit) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">        * 如果有配置项写入 则将配置项extend到setting对象上。</span><br><span class="line">        * 此处兼容了这个项目的之前的版本配置项的键名</span><br><span class="line">        *</span><br><span class="line">        **/</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(options) &#123;</span><br><span class="line">            <span class="comment">/* Maintain BC for a couple of versions. */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">undefined</span> !== options.failurelimit) &#123;</span><br><span class="line">                options.failure_limit = options.failurelimit; </span><br><span class="line">                <span class="keyword">delete</span> options.failurelimit;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">undefined</span> !== options.effectspeed) &#123;</span><br><span class="line">                options.effect_speed = options.effectspeed; </span><br><span class="line">                <span class="keyword">delete</span> options.effectspeed;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $.extend(settings, options);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Cache container as jQuery as object. */</span></span><br><span class="line">        $container = (settings.container === <span class="literal">undefined</span> ||</span><br><span class="line">                      settings.container === <span class="built_in">window</span>) ? $<span class="built_in">window</span> : $(settings.container);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Fire one scroll event per scroll. Not one scroll event per image. */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> === settings.event.indexOf(<span class="string">"scroll"</span>)) &#123;</span><br><span class="line">            $container.on(settings.event, <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> update();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里的this就是要实现懒加载的所有图片集合 &#123;object&#125;</span></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">        * 给所有懒加载的图片遍历绑定事件 分2种情况</span><br><span class="line">        * 1、setting配置scroll的时候</span><br><span class="line">        * 绑定自定义的appear事件</span><br><span class="line">        * 2、setting配置其他事件的时候 eq:click</span><br><span class="line">        * 给图片绑定click事件，并且句柄设置为appear</span><br><span class="line">        **/</span></span><br><span class="line">        <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">var</span> $self = $(self);</span><br><span class="line"></span><br><span class="line">            self.loaded = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When appear is triggered load original image. */</span></span><br><span class="line">            $self.one(<span class="string">"appear"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.loaded) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (settings.appear) &#123;</span><br><span class="line">                        <span class="keyword">var</span> elements_left = elements.length;</span><br><span class="line">                        settings.appear.call(self, elements_left, settings);</span><br><span class="line">                    &#125;</span><br><span class="line">                    $(<span class="string">"&lt;img /&gt;"</span>)</span><br><span class="line">                        .on(<span class="string">"load"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            $self</span><br><span class="line">                                .hide()</span><br><span class="line">                                .attr(<span class="string">"src"</span>, $self.data(settings.data_attribute))</span><br><span class="line">                                [settings.effect](settings.effect_speed);</span><br><span class="line">                            self.loaded = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">/* Remove image from array so it is not looped next time. */</span></span><br><span class="line">                            <span class="keyword">var</span> temp = $.grep(elements, <span class="function"><span class="keyword">function</span><span class="params">(element)</span> </span>&#123;</span><br><span class="line">                                <span class="keyword">return</span> !element.loaded;</span><br><span class="line">                            &#125;);</span><br><span class="line">                            elements = $(temp);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (settings.load) &#123;</span><br><span class="line">                                <span class="keyword">var</span> elements_left = elements.length;</span><br><span class="line">                                settings.load.call(self, elements_left, settings);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">                        .attr(<span class="string">"src"</span>, $self.data(settings.data_attribute));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When wanted event is triggered load original image */</span></span><br><span class="line">            <span class="comment">/* by triggering appear.                              */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span><br><span class="line">            * 如果配置项中得event不是scroll</span><br><span class="line">            * 就需要给每个图片绑定一个事件</span><br><span class="line">            * 比如click</span><br><span class="line">            **/</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> !== settings.event.indexOf(<span class="string">"scroll"</span>)) &#123;</span><br><span class="line">                $self.on(settings.event, <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!self.loaded) &#123;</span><br><span class="line">                        $self.trigger(<span class="string">"appear"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if something appears when window is resized. */</span></span><br><span class="line">        $<span class="built_in">window</span>.on(<span class="string">"resize"</span>, <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span><br><span class="line">            update();</span><br><span class="line">        &#125;);</span><br><span class="line">              </span><br><span class="line">        <span class="comment">/* With IOS5 force loading images when navigating with back button. */</span></span><br><span class="line">        <span class="comment">/* Non optimal workaround. */</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="regexp">/iphone|ipod|ipad.*os 5/gi</span>).test(navigator.appVersion)) &#123;</span><br><span class="line">            $<span class="built_in">window</span>.on(<span class="string">"pageshow"</span>, <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// if (event.originalEvent.persisted) &#123;</span></span><br><span class="line">                event = event.originalEvent || event;</span><br><span class="line">                <span class="keyword">if</span> (event.persisted) &#123;</span><br><span class="line">                    elements.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        $(<span class="keyword">this</span>).trigger(<span class="string">"appear"</span>);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Force initial check if images should appear. */</span></span><br><span class="line">        $(<span class="built_in">window</span>).on(<span class="string">"load"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            update();</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Convenience methods in jQuery namespace.           */</span></span><br><span class="line">    <span class="comment">/* Use as  $.belowthefold(element, &#123;threshold : 100, container : window&#125;) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">    * $.belowthefold &amp; $.rightoffold </span><br><span class="line">    * 是判断当前屏幕的最下方或最右方是否满足了加载图片的需求</span><br><span class="line">    * false 触发trigge('appear')</span><br><span class="line">    *</span><br><span class="line">    *</span><br><span class="line">    *</span><br><span class="line">    **/</span></span><br><span class="line">    $.belowthefold = <span class="function"><span class="keyword">function</span><span class="params">(element, settings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fold;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (settings.container === <span class="literal">undefined</span> || settings.container === <span class="built_in">window</span>) &#123;</span><br><span class="line">            fold = $<span class="built_in">window</span>.height() + $<span class="built_in">window</span>[<span class="number">0</span>].scrollY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fold = $(settings.container).offset().top + $(settings.container).height();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fold &lt;= $(element).offset().top - settings.threshold;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    $.rightoffold = <span class="function"><span class="keyword">function</span><span class="params">(element, settings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fold;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (settings.container === <span class="literal">undefined</span> || settings.container === <span class="built_in">window</span>) &#123;</span><br><span class="line">            fold = $<span class="built_in">window</span>.width() + $<span class="built_in">window</span>[<span class="number">0</span>].scrollX;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fold = $(settings.container).offset().left + $(settings.container).width();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fold &lt;= $(element).offset().left - settings.threshold;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">    * $.abovethetop &amp; $.leftofbegin </span><br><span class="line">    * 判断当前屏幕的最上方或最左方是否已经超过了需要加载的图片的位置</span><br><span class="line">    * true  nothing </span><br><span class="line">    *</span><br><span class="line">    *</span><br><span class="line">    *</span><br><span class="line">    **/</span> </span><br><span class="line">    $.abovethetop = <span class="function"><span class="keyword">function</span><span class="params">(element, settings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fold;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (settings.container === <span class="literal">undefined</span> || settings.container === <span class="built_in">window</span>) &#123;</span><br><span class="line">            fold = $<span class="built_in">window</span>[<span class="number">0</span>].scrollY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fold = $(settings.container).offset().top;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fold &gt;= $(element).offset().top + settings.threshold  + $(element).height();</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    $.leftofbegin = <span class="function"><span class="keyword">function</span><span class="params">(element, settings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fold;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (settings.container === <span class="literal">undefined</span> || settings.container === <span class="built_in">window</span>) &#123;</span><br><span class="line">            fold = $<span class="built_in">window</span>[<span class="number">0</span>].scrollX;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fold = $(settings.container).offset().left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fold &gt;= $(element).offset().left + settings.threshold + $(element).width();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    $.inviewport = <span class="function"><span class="keyword">function</span><span class="params">(element, settings)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> !$.rightoffold(element, settings) &amp;&amp; !$.leftofbegin(element, settings) &amp;&amp;</span><br><span class="line">                !$.belowthefold(element, settings) &amp;&amp; !$.abovethetop(element, settings);</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Custom selectors for your convenience.   */</span></span><br><span class="line">    <span class="comment">/* Use as $("img:below-the-fold").something() or */</span></span><br><span class="line">    <span class="comment">/* $("img").filter(":below-the-fold").something() which is faster */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">    * 添加选择器</span><br><span class="line">    * 通过筛选选择器可以方便的选出处于不同屏幕位置的图片</span><br><span class="line">    * 在jquery的空间里配置了一些实用的选择器，可以借鉴</span><br><span class="line">    *</span><br><span class="line">    **/</span></span><br><span class="line">    $.extend($.fn, &#123;</span><br><span class="line">        <span class="string">"below-the-fold"</span> : <span class="function"><span class="keyword">function</span><span class="params">(a)</span> </span>&#123; <span class="keyword">return</span> $.belowthefold(a, &#123;threshold : <span class="number">0</span>&#125;); &#125;,</span><br><span class="line">        <span class="string">"above-the-top"</span>  : <span class="function"><span class="keyword">function</span><span class="params">(a)</span> </span>&#123; <span class="keyword">return</span> !$.belowthefold(a, &#123;threshold : <span class="number">0</span>&#125;); &#125;,</span><br><span class="line">        <span class="string">"right-of-screen"</span>: <span class="function"><span class="keyword">function</span><span class="params">(a)</span> </span>&#123; <span class="keyword">return</span> $.rightoffold(a, &#123;threshold : <span class="number">0</span>&#125;); &#125;,</span><br><span class="line">        <span class="string">"left-of-screen"</span> : <span class="function"><span class="keyword">function</span><span class="params">(a)</span> </span>&#123; <span class="keyword">return</span> !$.rightoffold(a, &#123;threshold : <span class="number">0</span>&#125;); &#125;,</span><br><span class="line">        <span class="string">"in-viewport"</span>    : <span class="function"><span class="keyword">function</span><span class="params">(a)</span> </span>&#123; <span class="keyword">return</span> $.inviewport(a, &#123;threshold : <span class="number">0</span>&#125;); &#125;,</span><br><span class="line">        <span class="comment">/* Maintain BC for couple of versions. */</span></span><br><span class="line">        <span class="string">"above-the-fold"</span> : <span class="function"><span class="keyword">function</span><span class="params">(a)</span> </span>&#123; <span class="keyword">return</span> !$.belowthefold(a, &#123;threshold : <span class="number">0</span>&#125;); &#125;,</span><br><span class="line">        <span class="string">"right-of-fold"</span>  : <span class="function"><span class="keyword">function</span><span class="params">(a)</span> </span>&#123; <span class="keyword">return</span> $.rightoffold(a, &#123;threshold : <span class="number">0</span>&#125;); &#125;,</span><br><span class="line">        <span class="string">"left-of-fold"</span>   : <span class="function"><span class="keyword">function</span><span class="params">(a)</span> </span>&#123; <span class="keyword">return</span> !$.rightoffold(a, &#123;threshold : <span class="number">0</span>&#125;); &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;)($, <span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/09/28/lazyload-js源码学习/" data-id="ciifddu1q001bkgwl4b7vesqu" class="article-share-link" data-share="baidu">分享到</a>
      

      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-github学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/28/github学习/" class="article-date">
  <time datetime="2015-09-27T16:56:09.000Z" itemprop="datePublished">2015-09-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/28/github学习/">github学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="git_及github使用学习">git 及github使用学习</h2><p><strong>总结点：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分支合并后在git中操作<code>git branch</code>查看所有分支时分支还是会显示。并没有删除分支。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;merge操作时务必到主干上操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>git reflog</code>跟<code>git reset --hard xxx</code>组合是很好的规避失误操作的方法。reflog查看所有仓库HEAD状态，reset回到那个状态。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在主干master上执行reset操作时，不会影响到已经打好的分支。</p>
<blockquote>
<p>1、git init 初始化一个git项目</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在初始化的项目中有一个<code>.git</code>文件，可以被称为“附属于该仓库的工作树”。文件的操作都在工作树中进行，然后记录到仓库中去。</p>
<blockquote>
<p>2、git status 查看状态</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只要对git的工作树或者仓库操作，git status的现实结果就会发生变化。</p>
<blockquote>
<p>3、git add 向暂存区中添加文件<br>暂存区属于仓库的范畴</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如只是在工作区操作文件，并不会在被计入git仓库的版本管理对象中。用status查看状态时只会出现在Untracked files里，而git add操作后，文件就进入了暂存区即仓库。</p>
<blockquote>
<p>4、git commit 保存仓库的历史记录<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="operator"><span class="keyword">commit</span> <span class="comment">--amend</span></span><br><span class="line">//修改上一次提交的信息</span><br><span class="line">git <span class="keyword">commit</span> -am <span class="string">"message"</span></span><br><span class="line">//<span class="keyword">add</span> <span class="keyword">commit</span> &amp; 提交信息</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将当前暂存区的的文件实际保存到仓库的历史记录。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过这些记录我们就可以在工作区内复原文件。</p>
<blockquote>
<p>5、git log 查看提交的记录，也是保存过的仓库的记录。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment">--pretty=short</span><span class="comment"></span><br><span class="line">//不显示日期</span></span><br><span class="line">git <span class="built_in">log</span> -p README.md<span class="comment"></span><br><span class="line">//读取READMD.md文件提交记录，-p代表了前后差异</span></span><br><span class="line">git <span class="built_in">log</span> README.md <span class="comment"></span><br><span class="line">//读取特定文件的提交记录</span></span><br><span class="line">git <span class="built_in">log</span> graph<span class="comment"></span><br><span class="line">//以图表形式查看分支</span></span><br></pre></td></tr></table></figure></p>
<p>6、git diff 查看更改前后的差别</p>
</blockquote>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD</span><br><span class="line"><span class="comment">//比较工作树和最新提交之间的差别。</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;git diff 可以查看工作树、暂存区、最新提交之间的差异。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认情况下<code>git diff</code>比较的是工作树和暂存区的区别，如果此分支在<code>git add</code>之后工作树跟暂存区区别是没有的，所以在add之后commit之前需要使用<code>git diff HEAD</code>比较工作树和最新提交之间的差别。</p>
<blockquote>
<p>7、git branch 显示分支一览表</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显示当前的仓库的所有分支。并且当前分支带有<strong>星号</strong>标志。</p>
<blockquote>
<p>8、git checkout -b feature-A  创建并切换到分支。<br>git branch feature-A 创建分支<br>git checkout feature-A 切换到feature-A分支</p>
</blockquote>
<p>打分支</p>
<blockquote>
<p>9、git merge 合并分支</p>
</blockquote>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">merge</span> <span class="comment">--no-ff 分支</span><span class="comment"></span><br><span class="line">//在记录中记录本此合并</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>10、git reset —hard xxx让仓库的HEAD、暂存区、和当前工作树回溯到指定版本</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回溯之后查看log日志只能看到当前状态之前的日志，就看不到回溯之前的那些日志，如果回溯错了，想回到回溯之前的状态该怎么办？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只用<code>git reflog</code>操作就能看到包括回溯之前的所有状态，然后再配合<code>git reset --hard</code>命令回溯回去就好了。<br>git</p>
<blockquote>
<p>11、git rebase -i HEAD~2（num）</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果觉得两次提交的内容和信息台贴近无需分成两次，就可以使用这个命令两xx条最近的HEAD合并成一条提交。<br>执行后回出现编辑框<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pick <span class="number">7</span>aadfd <span class="string">"add feature"</span></span><br><span class="line">pick <span class="number">4</span>tw436 <span class="string">"dsxxxx"</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt;&gt;&gt;&gt;修改成</span><br><span class="line">pick <span class="number">7</span>aadfd <span class="string">"add feature"</span></span><br><span class="line">fixup <span class="number">4</span>tw436 <span class="string">"dsxxxx"</span></span><br><span class="line">/<span class="regexp">/意味着将第二条修改加到第一条去</span></span><br></pre></td></tr></table></figure></p>
<h2 id="第三方开发者协作"><strong>第三方开发者协作</strong></h2><blockquote>
<p>12、git remote add origin git@github.com:fromiris/git-test.git<br>将远程仓库链接到本地仓库，并且讲远程仓库名字设置成origin</p>
<p>13、git push -u origin master<br>-u origin master 参数 表示将origin的master分支设置成本地master分支的upstream，这样以后pull时可以直接获取</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果是在本地开了一个分支并且推送到远程仓库也是这个语句。<br><code>git push -u origin feature-D</code><br>并且将远端的feature-D分支当成本地feature-D分支的upstream<br>这样之后在push只用<code>git push</code>就好了。</p>
<blockquote>
<p>1、git clone git@github.com:fromiris/git-test.git<br>clone操作默认克隆远程仓库的master分支，并不包含其他分支。</p>
</blockquote>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -<span class="literal">a</span></span><br><span class="line">//这个命令查看当前分支的相关信息，添加<span class="escape">`-</span><span class="literal">a</span><span class="escape">`参</span>数可以同时显示本地仓库和远程仓库的分支情况。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2、checkout -b feature-D origin/feature-D</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clone下仓库后并没有clone下其他分支，所以需要自己手动去在本地开分支，并且设定好远程仓库分支的来源。</p>
<blockquote>
<p>3、git pull origin feature-D<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从远端的featur-D分支拉取最新的数据，如果第一次push设置了<br><code>git push -u origin feature-D</code>之后在这个分支上直接pull就好了。</p>
</blockquote>
<h2 id="github上的一些操作"><strong>github上的一些操作</strong></h2><blockquote>
<p>1、Gist </p>
</blockquote>
<p>存放一些没必要放入一个仓库的代码片段，比如一些简单的组件js等。</p>
<blockquote>
<p>2、行号</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在具体仓库里的脚本文件，点击左侧可以在url中出现当前行的锚点。<br><img src="./1443275342434.png" alt="Alt text"><br>这个功能适合人员之间进行讨论。</p>
<blockquote>
<p>3、在仓库中快速查找 <code>t</code></p>
</blockquote>
<p><img src="./1443275543433.png" alt="Alt text"></p>
<blockquote>
<p>4、issue </p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前在issue里程序员一般都会探讨一些技术问题，追踪bug等，现在的issue可以做更多事情。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如开源项目规划排期，写博客</p>
<ul>
<li>[ ] 我的</li>
<li>[x] 你得</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提交信息可以跟issus的编号绑定。<br><img src="./1443278089709.png" alt="Alt text"><br>这个#1就是这个开着的issus的编号，在代码commit的时候提交信息里出现#1，那么这个issue就会跟提交绑定。<br><img src="./1443278184749.png" alt="Alt text"><br>同样，在提交信息里加上<code>close#1</code>就会把相关的issue关闭，省去了代码完成后还要一层层去找issue去关闭的现象。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>issus跟pull request</strong>的编号是通用的。</p>
<blockquote>
<p>5、pull request</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/09/28/github学习/" data-id="ciifddu1u001fkgwlsxcib21n" class="article-share-link" data-share="baidu">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/杂/">杂</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分類</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/html-css/">html&css</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动画库/">动画库</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">標簽</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Regexp/">Regexp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html-css/">html&css</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jsLib/">jsLib</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web移动端/">web移动端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/书籍阅读/">书籍阅读</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端性能监控/">前端性能监控</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端调试/">前端调试</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂/">杂</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">標簽雲</h3>
    <div class="widget tagcloud">
      <a href="/tags/Regexp/" style="font-size: 10px;">Regexp</a><a href="/tags/html-css/" style="font-size: 10px;">html&css</a><a href="/tags/javascript/" style="font-size: 20px;">javascript</a><a href="/tags/js/" style="font-size: 10px;">js</a><a href="/tags/jsLib/" style="font-size: 10px;">jsLib</a><a href="/tags/web移动端/" style="font-size: 10px;">web移动端</a><a href="/tags/书籍阅读/" style="font-size: 15px;">书籍阅读</a><a href="/tags/前端性能监控/" style="font-size: 10px;">前端性能监控</a><a href="/tags/前端调试/" style="font-size: 10px;">前端调试</a><a href="/tags/杂/" style="font-size: 15px;">杂</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">歸檔</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/12/20/移动端调试/">移动端调试</a>
          </li>
        
          <li>
            <a href="/2015/12/07/基于Gulp的前端静态页面开发工作流的思考/">基于Gulp的前端静态页面开发工作流的思考</a>
          </li>
        
          <li>
            <a href="/2015/11/29/The-Principles-of-object-oriented-javascript阅读笔记/">The Principles of object-oriented javascript阅读笔记</a>
          </li>
        
          <li>
            <a href="/2015/11/15/编写可维护的javascript阅读笔记/">编写可维护的javascript阅读笔记</a>
          </li>
        
          <li>
            <a href="/2015/11/12/破译关键渲染路径（翻译）/">破译关键渲染路径（翻译）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情鏈接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://xiguabaobao.com" target="_blank">主题作者</a>
          </li>
        
          <li>
            <a href="http://reqianduan.com" target="_blank">热前端</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Lyu Dada<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="https://github.com/fromIRIS" class="mobile-nav-link">MYGithub</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回頂部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>window._bd_share_config={"common":{},"share":{"bdCustomStyle":"/css/bdshare.css"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js" type="text/javascript"></script>

</div>
</body>
</html>
